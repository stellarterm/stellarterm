<!doctype html><html>
  <head>
    <meta charset="utf-8">
    <title>StellarTerm: Stellar Trading Client</title>
    <meta name="description" content="Trade on the Stellar Decentralized Exchange. StellarTerm is an open source client for the Stellar network. Send, receive, and trade assets on the Stellar network easily with StellarTerm.">
    <meta name="viewport" content="width=1080">
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="icon" sizes="16x16 32x32 64x64" href="/favicon.ico">
    <link rel="icon" type="image/png" sizes="196x196" href="/favicon-192.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96.png">
    <link rel="icon" type="image/png" sizes="64x64" href="/favicon-64.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16.png">
    <link rel="stylesheet" href="css/app.css" inline>
  </head>
  <body>
    <div id="app"></div>
    <script src="./customConfig.js" inline></script>
    <script src="./buildInfo.js" inline></script>
    <script src="./bower_components/highcharts/highstock.js" inline></script>
    <script src="./bower_components/stellar-sdk/stellar-sdk.min.js" inline></script>
    <!-- stellar-ledger-api is placed here due to a weird bug in gulp inliner -->
    <!-- Copy-paste is intentional as it reduces the amount of dependencies -->
    <script>
      (function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.LedgerjsStellar = f()}})(function(){var define,module,exports;return (function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
        (function (Buffer){
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

          var _createClass2 = require("babel-runtime/helpers/createClass");

          var _createClass3 = _interopRequireDefault(_createClass2);

          var _utils = require("./utils");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          /********************************************************************************
           *   Ledger Node JS API
           *   (c) 2017-2018 Ledger
           *
           *  Licensed under the Apache License, Version 2.0 (the "License");
           *  you may not use this file except in compliance with the License.
           *  You may obtain a copy of the License at
           *
           *      http://www.apache.org/licenses/LICENSE-2.0
           *
           *  Unless required by applicable law or agreed to in writing, software
           *  distributed under the License is distributed on an "AS IS" BASIS,
           *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           *  See the License for the specific language governing permissions and
           *  limitations under the License.
           ********************************************************************************/
          var CLA = 0xe0;
          var INS_GET_PK = 0x02;
          var INS_SIGN_TX = 0x04;
          var INS_GET_CONF = 0x06;
          var INS_SIGN_TX_HASH = 0x08;

          var APDU_MAX_SIZE = 150;
          var P1_FIRST_APDU = 0x00;
          var P1_MORE_APDU = 0x80;
          var P2_LAST_APDU = 0x00;
          var P2_MORE_APDU = 0x80;

          var SW_OK = 0x9000;
          var SW_CANCEL = 0x6985;
          var SW_UNKNOWN_OP = 0x6c24;

          /**
           * Stellar API
           *
           * @example
           * import Str from "@ledgerhq/hw-app-str";
           * const str = new Str(transport)
           */

          var Str = function () {
            function Str(transport) {
              (0, _classCallCheck3.default)(this, Str);

              this.transport = transport;
              transport.setScrambleKey("l0v");
            }

            (0, _createClass3.default)(Str, [{
              key: "getAppConfiguration",
              value: function getAppConfiguration() {
                return this.transport.send(CLA, INS_GET_CONF, 0x00, 0x00).then(function (response) {
                  var version = "" + response[1] + "." + response[2] + "." + response[3];
                  return {
                    version: version
                  };
                });
              }

              /**
               * get Stellar public key for a given BIP 32 path.
               * @param path a path in BIP 32 format
               * @option boolValidate optionally enable key pair validation
               * @option boolDisplay optionally enable or not the display
               * @return an object with the publicKey
               * @example
               * str.getPublicKey("44'/148'/0'").then(o => o.publicKey)
               */

            }, {
              key: "getPublicKey",
              value: function getPublicKey(path, boolValidate, boolDisplay) {
                var pathElts = (0, _utils.splitPath)(path);
                var buffer = new Buffer(1 + pathElts.length * 4);
                buffer[0] = pathElts.length;
                pathElts.forEach(function (element, index) {
                  buffer.writeUInt32BE(element, 1 + 4 * index);
                });
                var verifyMsg = Buffer.from("via lumina", "ascii");
                buffer = Buffer.concat([buffer, verifyMsg]);
                return this.transport.send(CLA, INS_GET_PK, boolValidate ? 0x01 : 0x00, boolDisplay ? 0x01 : 0x00, buffer).then(function (response) {
                  // response = Buffer.from(response, 'hex');
                  var offset = 0;
                  var rawPublicKey = response.slice(offset, offset + 32);
                  offset += 32;
                  var publicKey = (0, _utils.encodeEd25519PublicKey)(rawPublicKey);
                  if (boolValidate) {
                    var _signature = response.slice(offset, offset + 64);
                    if (!(0, _utils.verifyEd25519Signature)(verifyMsg, _signature, rawPublicKey)) {
                      throw new Error("Bad signature. Keypair is invalid. Please report this.");
                    }
                  }
                  return {
                    publicKey: publicKey
                  };
                });
              }

              /**
               * sign a Stellar transaction.
               * @param path a path in BIP 32 format
               * @param transaction signature base of the transaction to sign
               * @return an object with the signature and the status
               * @example
               * str.signTransaction("44'/148'/0'", signatureBase).then(o => o.signature)
               */

            }, {
              key: "signTransaction",
              value: function signTransaction(path, transaction) {
                var _this = this;

                (0, _utils.checkStellarBip32Path)(path);

                var apdus = [];
                var response = void 0;

                var pathElts = (0, _utils.splitPath)(path);
                var bufferSize = 1 + pathElts.length * 4;
                var buffer = Buffer.alloc(bufferSize);
                buffer[0] = pathElts.length;
                pathElts.forEach(function (element, index) {
                  buffer.writeUInt32BE(element, 1 + 4 * index);
                });
                var chunkSize = APDU_MAX_SIZE - bufferSize;
                if (transaction.length <= chunkSize) {
                  // it fits in a single apdu
                  apdus.push(Buffer.concat([buffer, transaction]));
                } else {
                  // we need to send multiple apdus to transmit the entire transaction
                  var chunk = Buffer.alloc(chunkSize);
                  var offset = 0;
                  transaction.copy(chunk, 0, offset, chunkSize);
                  apdus.push(Buffer.concat([buffer, chunk]));
                  offset += chunkSize;
                  while (offset < transaction.length) {
                    var remaining = transaction.length - offset;
                    chunkSize = remaining < APDU_MAX_SIZE ? remaining : APDU_MAX_SIZE;
                    chunk = Buffer.alloc(chunkSize);
                    transaction.copy(chunk, 0, offset, offset + chunkSize);
                    offset += chunkSize;
                    apdus.push(chunk);
                  }
                }
                return (0, _utils.foreach)(apdus, function (data, i) {
                  return _this.transport.send(CLA, INS_SIGN_TX, i === 0 ? P1_FIRST_APDU : P1_MORE_APDU, i === apdus.length - 1 ? P2_LAST_APDU : P2_MORE_APDU, data, [SW_OK, SW_CANCEL, SW_UNKNOWN_OP]).then(function (apduResponse) {
                    response = apduResponse;
                  });
                }).then(function () {
                  var status = Buffer.from(response.slice(response.length - 2)).readUInt16BE(0);
                  if (status === SW_OK) {
                    var _signature2 = Buffer.from(response.slice(0, response.length - 2));
                    return {
                      signature: _signature2
                    };
                  } else if (status === SW_UNKNOWN_OP) {
                    // pre-v2 app version: fall back on hash signing
                    return _this.signHash(path, (0, _utils.hash)(transaction));
                  } else {
                    throw new Error("Transaction approval request was rejected");
                  }
                });
              }

              /**
               * @deprecated
               * sign a Stellar transaction hash.
               * @param path a path in BIP 32 format
               * @param hash hash of the transaction to sign
               * @return an object with the signature
               * @example
               * str.signHash("44'/148'/0'", hash).then(o => o.signature)
               */

            }, {
              key: "signHash",
              value: function signHash(path, hash) {
                var pathElts = (0, _utils.splitPath)(path);
                var buffer = Buffer.alloc(1 + pathElts.length * 4);
                buffer[0] = pathElts.length;
                pathElts.forEach(function (element, index) {
                  buffer.writeUInt32BE(element, 1 + 4 * index);
                });
                buffer = Buffer.concat([buffer, hash]);
                return this.transport.send(CLA, INS_SIGN_TX_HASH, 0x00, 0x00, buffer, [SW_OK, SW_CANCEL]).then(function (response) {
                  var status = Buffer.from(response.slice(response.length - 2)).readUInt16BE(0);
                  if (status === SW_OK) {
                    var _signature3 = Buffer.from(response.slice(0, response.length - 2));
                    return {
                      signature: _signature3
                    };
                  } else {
                    throw new Error("Transaction approval request was rejected");
                  }
                });
              }
            }]);
            return Str;
          }();

          exports.default = Str;

        }).call(this,require("buffer").Buffer)
      },{"./utils":2,"babel-runtime/helpers/classCallCheck":14,"babel-runtime/helpers/createClass":15,"buffer":24}],2:[function(require,module,exports){
        (function (Buffer){
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _promise = require("babel-runtime/core-js/promise");

          var _promise2 = _interopRequireDefault(_promise);

          exports.splitPath = splitPath;
          exports.foreach = foreach;
          exports.encodeEd25519PublicKey = encodeEd25519PublicKey;
          exports.verifyEd25519Signature = verifyEd25519Signature;
          exports.hash = hash;
          exports.checkStellarBip32Path = checkStellarBip32Path;

          var _crc16_xmodem = require("crc/lib/crc16_xmodem");

          var _crc16_xmodem2 = _interopRequireDefault(_crc16_xmodem);

          var _base = require("base32.js");

          var _base2 = _interopRequireDefault(_base);

          var _tweetnacl = require("tweetnacl");

          var _tweetnacl2 = _interopRequireDefault(_tweetnacl);

          var _sha = require("sha.js");

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO use bip32-path library
          /********************************************************************************
           *   Ledger Node JS API
           *   (c) 2017-2018 Ledger
           *
           *  Licensed under the Apache License, Version 2.0 (the "License");
           *  you may not use this file except in compliance with the License.
           *  You may obtain a copy of the License at
           *
           *      http://www.apache.org/licenses/LICENSE-2.0
           *
           *  Unless required by applicable law or agreed to in writing, software
           *  distributed under the License is distributed on an "AS IS" BASIS,
           *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
           *  See the License for the specific language governing permissions and
           *  limitations under the License.
           ********************************************************************************/
          function splitPath(path) {
            var result = [];
            var components = path.split("/");
            components.forEach(function (element) {
              var number = parseInt(element, 10);
              if (isNaN(number)) {
                return; // FIXME shouldn't it throws instead?
              }
              if (element.length > 1 && element[element.length - 1] === "'") {
                number += 0x80000000;
              }
              result.push(number);
            });
            return result;
          }

          function foreach(arr, callback) {
            function iterate(index, array, result) {
              if (index >= array.length) {
                return result;
              } else {
                return callback(array[index], index).then(function (res) {
                  result.push(res);
                  return iterate(index + 1, array, result);
                });
              }
            }
            return _promise2.default.resolve().then(function () {
              return iterate(0, arr, []);
            });
          }

          function encodeEd25519PublicKey(rawPublicKey) {
            var versionByte = 6 << 3; // 'G'
            var data = Buffer.from(rawPublicKey);
            var versionBuffer = Buffer.from([versionByte]);
            var payload = Buffer.concat([versionBuffer, data]);
            var checksum = Buffer.alloc(2);
            checksum.writeUInt16LE((0, _crc16_xmodem2.default)(payload), 0);
            var unencoded = Buffer.concat([payload, checksum]);
            return _base2.default.encode(unencoded);
          }

          function verifyEd25519Signature(data, signature, publicKey) {
            return _tweetnacl2.default.sign.detached.verify(new Uint8Array(data.toJSON().data), new Uint8Array(signature.toJSON().data), new Uint8Array(publicKey.toJSON().data));
          }

          function hash(data) {
            var hasher = new _sha.sha256();
            hasher.update(data, "utf8");
            return hasher.digest();
          }

          function checkStellarBip32Path(path) {
            if (!path.startsWith("44'/148'")) {
              throw new Error("Not a Stellar BIP32 path. Path: " + path + "." + " The Stellar app is authorized only for paths starting with 44'/148'." + " Example: 44'/148'/0'");
            }
            path.split("/").forEach(function (element) {
              if (!element.toString().endsWith("'")) {
                throw new Error("Detected a non-hardened path element in requested BIP32 path." + " Non-hardended paths are not supported at this time. Please use an all-hardened path." + " Example: 44'/148'/0'");
              }
            });
          }

        }).call(this,require("buffer").Buffer)
      },{"babel-runtime/core-js/promise":10,"base32.js":21,"buffer":24,"crc/lib/crc16_xmodem":122,"sha.js":133,"tweetnacl":140}],3:[function(require,module,exports){
        (function (Buffer){
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });

          var _promise = require("babel-runtime/core-js/promise");

          var _promise2 = _interopRequireDefault(_promise);

          var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

          var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

          var _regenerator = require("babel-runtime/regenerator");

          var _regenerator2 = _interopRequireDefault(_regenerator);

          var _typeof2 = require("babel-runtime/helpers/typeof");

          var _typeof3 = _interopRequireDefault(_typeof2);

          var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

          var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

          var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

          var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

          var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

          var _createClass2 = require("babel-runtime/helpers/createClass");

          var _createClass3 = _interopRequireDefault(_createClass2);

          var _inherits2 = require("babel-runtime/helpers/inherits");

          var _inherits3 = _interopRequireDefault(_inherits2);

          var _u2fApi = require("u2f-api");

          var _hwTransport = require("@ledgerhq/hw-transport");

          var _hwTransport2 = _interopRequireDefault(_hwTransport);

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          function wrapU2FTransportError(originalError, message, id) {
            var err = new _hwTransport.TransportError(message, id);
            // $FlowFixMe
            err.originalError = originalError;
            return err;
          }

          function wrapApdu(apdu, key) {
            var result = Buffer.alloc(apdu.length);
            for (var i = 0; i < apdu.length; i++) {
              result[i] = apdu[i] ^ key[i % key.length];
            }
            return result;
          }

// Convert from normal to web-safe, strip trailing "="s
          var webSafe64 = function webSafe64(base64) {
            return base64.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
          };

// Convert from web-safe to normal, add trailing "="s
          var normal64 = function normal64(base64) {
            return base64.replace(/-/g, "+").replace(/_/g, "/") + "==".substring(0, 3 * base64.length % 4);
          };

          function attemptExchange(apdu, timeoutMillis, debug, scrambleKey) {
            var keyHandle = wrapApdu(apdu, scrambleKey);
            var challenge = Buffer.from("0000000000000000000000000000000000000000000000000000000000000000", "hex");
            var signRequest = {
              version: "U2F_V2",
              keyHandle: webSafe64(keyHandle.toString("base64")),
              challenge: webSafe64(challenge.toString("base64")),
              appId: location.origin
            };
            if (debug) {
              console.log("=> " + apdu.toString("hex"));
            }
            return (0, _u2fApi.sign)(signRequest, timeoutMillis / 1000).then(function (response) {
              var signatureData = response.signatureData;

              if (typeof signatureData === "string") {
                var data = Buffer.from(normal64(signatureData), "base64");
                var result = data.slice(5);
                if (debug) {
                  console.log("<= " + result.toString("hex"));
                }
                return result;
              } else {
                throw response;
              }
            });
          }

          var transportInstances = [];

          function emitDisconnect() {
            transportInstances.forEach(function (t) {
              return t.emit("disconnect");
            });
            transportInstances = [];
          }

          function isTimeoutU2FError(u2fError) {
            return u2fError.metaData.code === 5;
          }

          /**
           * U2F web Transport implementation
           * @example
           * import TransportU2F from "@ledgerhq/hw-transport-u2f";
           * ...
           * TransportU2F.create().then(transport => ...)
           */

          var TransportU2F = function (_Transport) {
            (0, _inherits3.default)(TransportU2F, _Transport);
            (0, _createClass3.default)(TransportU2F, null, [{
              key: "open",


              /**
               * static function to create a new Transport from a connected Ledger device discoverable via U2F (browser support)
               */
              value: function () {
                var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(_) {
                  var openTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5000;
                  var isU2FError;
                  return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.prev = 0;
                          _context.next = 3;
                          return attemptExchange(Buffer.alloc(0), openTimeout, false, Buffer.alloc(1));

                        case 3:
                          _context.next = 17;
                          break;

                        case 5:
                          _context.prev = 5;
                          _context.t0 = _context["catch"](0);
                          isU2FError = (0, _typeof3.default)(_context.t0.metaData) === "object";

                          if (!isU2FError) {
                            _context.next = 16;
                            break;
                          }

                          if (!isTimeoutU2FError(_context.t0)) {
                            _context.next = 14;
                            break;
                          }

                          emitDisconnect();
                          throw wrapU2FTransportError(_context.t0, "Ledger device unreachable.\n" + "Make sure the device is plugged, unlocked and with the correct application opened." + (location && location.protocol !== "https:" ? "\nYou are not running on HTTPS. U2F is likely to not work in unsecure protocol." : ""), "Timeout");

                        case 14:
                          _context.next = 17;
                          break;

                        case 16:
                          throw _context.t0;

                        case 17:
                          return _context.abrupt("return", new TransportU2F());

                        case 18:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, this, [[0, 5]]);
                }));

                function open(_x) {
                  return _ref.apply(this, arguments);
                }

                return open;
              }()

              // this transport is not discoverable but we are going to guess if it is here with isSupported()

            }]);

            function TransportU2F() {
              (0, _classCallCheck3.default)(this, TransportU2F);

              var _this = (0, _possibleConstructorReturn3.default)(this, (TransportU2F.__proto__ || (0, _getPrototypeOf2.default)(TransportU2F)).call(this));

              transportInstances.push(_this);
              return _this;
            }

            (0, _createClass3.default)(TransportU2F, [{
              key: "exchange",
              value: function () {
                var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(apdu) {
                  var isU2FError;
                  return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                      switch (_context2.prev = _context2.next) {
                        case 0:
                          _context2.prev = 0;
                          _context2.next = 3;
                          return attemptExchange(apdu, this.exchangeTimeout, this.debug, this.scrambleKey);

                        case 3:
                          return _context2.abrupt("return", _context2.sent);

                        case 6:
                          _context2.prev = 6;
                          _context2.t0 = _context2["catch"](0);
                          isU2FError = (0, _typeof3.default)(_context2.t0.metaData) === "object";

                          if (!isU2FError) {
                            _context2.next = 14;
                            break;
                          }

                          if (isTimeoutU2FError(_context2.t0)) {
                            emitDisconnect();
                          }
                          // the wrapping make error more usable and "printable" to the end user.
                          throw wrapU2FTransportError(_context2.t0, "Failed to sign with Ledger device: U2F " + _context2.t0.metaData.type, "U2F_" + _context2.t0.metaData.code);

                        case 14:
                          throw _context2.t0;

                        case 15:
                        case "end":
                          return _context2.stop();
                      }
                    }
                  }, _callee2, this, [[0, 6]]);
                }));

                function exchange(_x3) {
                  return _ref2.apply(this, arguments);
                }

                return exchange;
              }()
            }, {
              key: "setScrambleKey",
              value: function setScrambleKey(scrambleKey) {
                this.scrambleKey = Buffer.from(scrambleKey, "ascii");
              }
            }, {
              key: "close",
              value: function close() {
                var i = transportInstances.indexOf(this);
                if (i === -1) {
                  throw new Error("invalid transport instance");
                }
                transportInstances.splice(i, 1);
                return _promise2.default.resolve();
              }
            }]);
            return TransportU2F;
          }(_hwTransport2.default);

          TransportU2F.isSupported = _u2fApi.isSupported;

          TransportU2F.list = function () {
            return (0, _u2fApi.isSupported)().then(function (supported) {
              return supported ? [null] : [];
            });
          };

          TransportU2F.listen = function (observer) {
            var unsubscribed = false;
            (0, _u2fApi.isSupported)().then(function (supported) {
              if (unsubscribed) return;
              if (supported) {
                observer.next({ type: "add", descriptor: null });
                observer.complete();
              } else {
                observer.error(new _hwTransport.TransportError("U2F browser support is needed for Ledger. " + "Please use Chrome, Opera or Firefox with a U2F extension. " + "Also make sure you're on an HTTPS connection", "U2FNotSupported"));
              }
            });
            return {
              unsubscribe: function unsubscribe() {
                unsubscribed = true;
              }
            };
          };

          exports.default = TransportU2F;

        }).call(this,require("buffer").Buffer)
      },{"@ledgerhq/hw-transport":4,"babel-runtime/core-js/object/get-prototype-of":8,"babel-runtime/core-js/promise":10,"babel-runtime/helpers/asyncToGenerator":13,"babel-runtime/helpers/classCallCheck":14,"babel-runtime/helpers/createClass":15,"babel-runtime/helpers/inherits":16,"babel-runtime/helpers/possibleConstructorReturn":17,"babel-runtime/helpers/typeof":19,"babel-runtime/regenerator":20,"buffer":24,"u2f-api":141}],4:[function(require,module,exports){
        (function (Buffer){
          "use strict";

          Object.defineProperty(exports, "__esModule", {
            value: true
          });
          exports.StatusCodes = undefined;

          var _promise = require("babel-runtime/core-js/promise");

          var _promise2 = _interopRequireDefault(_promise);

          var _toConsumableArray2 = require("babel-runtime/helpers/toConsumableArray");

          var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

          var _regenerator = require("babel-runtime/regenerator");

          var _regenerator2 = _interopRequireDefault(_regenerator);

          var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

          var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

          var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

          var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

          var _createClass2 = require("babel-runtime/helpers/createClass");

          var _createClass3 = _interopRequireDefault(_createClass2);

          exports.TransportError = TransportError;
          exports.TransportStatusError = TransportStatusError;

          var _events2 = require("events");

          var _events3 = _interopRequireDefault(_events2);

          function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

          /**
           * all possible status codes.
           * @see https://ledgerhq.github.io/btchip-doc/bitcoin-technical.html#_status_words
           * @example
           * import { StatusCodes } from "@ledgerhq/hw-transport";
           */


          /**
           */


          /**
           */


          /**
           */

          /**
           */
          var StatusCodes = exports.StatusCodes = {
            /**
             * Incorrect length
             */
            IncorrectLength: 0x6700,
            /**
             * Security status not satisfied (Bitcoin dongle is locked or invalid access rights)
             */
            SecurityNotSatisfied: 0x6982,
            /**
             * Invalid data
             */
            InvalidData: 0x6a80,
            /**
             * File not found
             */
            FileNotFound: 0x6a82,
            /**
             * Incorrect parameter P1 or P2
             */
            IncorrectParameter: 0x6b00,
            /**
             * Success
             */
            Success: 0x9000
          };

          /**
           * TransportError is used for any generic transport errors.
           * e.g. Error thrown when data received by exchanges are incorrect or if exchanged failed to communicate with the device for various reason.
           */


          function TransportError(message, id) {
            this.name = "TransportError";
            this.message = message;
            this.stack = new Error().stack;
            this.id = id;
          }
//$FlowFixMe
          TransportError.prototype = new Error();

          /**
           * Error thrown when a device returned a non success status.
           * the error.statusCode is one of the `StatusCodes` exported by this library.
           */
          function TransportStatusError(statusCode) {
            this.name = "TransportStatusError";
            this.message = "Invalid status " + statusCode.toString(16);
            this.stack = new Error().stack;
            this.statusCode = statusCode;
          }
//$FlowFixMe
          TransportStatusError.prototype = new Error();

          /**
           * Transport defines the generic interface to share between node/u2f impl
           * A **Descriptor** is a parametric type that is up to be determined for the implementation.
           * it can be for instance an ID, an file path, a URL,...
           */

          var Transport = function () {
            function Transport() {
              var _this = this;

              (0, _classCallCheck3.default)(this, Transport);
              this.debug = false;
              this.exchangeTimeout = 30000;
              this._events = new _events3.default();

              this.send = function () {
                var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(cla, ins, p1, p2) {
                  var data = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Buffer.alloc(0);
                  var statusList = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [StatusCodes.Success];
                  var response, sw;
                  return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          if (!(data.length >= 256)) {
                            _context.next = 2;
                            break;
                          }

                          throw new TransportError("data.length exceed 256 bytes limit. Got: " + data.length, "DataLengthTooBig");

                        case 2:
                          _context.next = 4;
                          return _this.exchange(Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]));

                        case 4:
                          response = _context.sent;
                          sw = response.readUInt16BE(response.length - 2);

                          if (statusList.some(function (s) {
                              return s === sw;
                            })) {
                            _context.next = 8;
                            break;
                          }

                          throw new TransportStatusError(sw);

                        case 8:
                          return _context.abrupt("return", response);

                        case 9:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, _this);
                }));

                return function (_x, _x2, _x3, _x4) {
                  return _ref.apply(this, arguments);
                };
              }();
            }

            /**
             * Statically check if a transport is supported on the user's platform/browser.
             */


            /**
             * List once all available descriptors. For a better granularity, checkout `listen()`.
             * @return a promise of descriptors
             * @example
             * TransportFoo.list().then(descriptors => ...)
             */


            /**
             * Listen all device events for a given Transport. The method takes an Obverver of DescriptorEvent and returns a Subscription (according to Observable paradigm https://github.com/tc39/proposal-observable )
             * a DescriptorEvent is a `{ descriptor, type }` object. type can be `"add"` or `"remove"` and descriptor is a value you can pass to `open(descriptor)`.
             * each listen() call will first emit all potential device already connected and then will emit events can come over times,
             * for instance if you plug a USB device after listen() or a bluetooth device become discoverable.
             * @param observer is an object with a next, error and complete function (compatible with observer pattern)
             * @return a Subscription object on which you can `.unsubscribe()` to stop listening descriptors.
             * @example
             const sub = TransportFoo.listen({
  next: e => {
    if (e.type==="add") {
      sub.unsubscribe();
      const transport = await TransportFoo.open(e.descriptor);
      ...
    }
  },
  error: error => {},
  complete: () => {}
  })
             */


            /**
             * attempt to create a Transport instance with potentially a descriptor.
             * @param descriptor: the descriptor to open the transport with.
             * @param timeout: an optional timeout
             * @return a Promise of Transport instance
             * @example
             TransportFoo.open(descriptor).then(transport => ...)
             */


            /**
             * low level api to communicate with the device
             * This method is for implementations to implement but should not be directly called.
             * Instead, the recommanded way is to use send() method
             * @param apdu the data to send
             * @return a Promise of response data
             */


            /**
             * set the "scramble key" for the next exchanges with the device.
             * Each App can have a different scramble key and they internally will set it at instanciation.
             * @param key the scramble key
             */


            /**
             * close the exchange with the device.
             * @return a Promise that ends when the transport is closed.
             */


            (0, _createClass3.default)(Transport, [{
              key: "on",


              /**
               * Listen to an event on an instance of transport.
               * Transport implementation can have specific events. Here is the common events:
               * * `"disconnect"` : triggered if Transport is disconnected
               */
              value: function on(eventName, cb) {
                this._events.on(eventName, cb);
              }

              /**
               * Stop listening to an event on an instance of transport.
               */

            }, {
              key: "off",
              value: function off(eventName, cb) {
                this._events.removeListener(eventName, cb);
              }
            }, {
              key: "emit",
              value: function emit(event) {
                var _events;

                for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                  args[_key - 1] = arguments[_key];
                }

                (_events = this._events).emit.apply(_events, [event].concat((0, _toConsumableArray3.default)(args)));
              }

              /**
               * Enable or not logs of the binary exchange
               */

            }, {
              key: "setDebugMode",
              value: function setDebugMode(debug) {
                this.debug = debug;
              }

              /**
               * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)
               */

            }, {
              key: "setExchangeTimeout",
              value: function setExchangeTimeout(exchangeTimeout) {
                this.exchangeTimeout = exchangeTimeout;
              }

              /**
               * wrapper on top of exchange to simplify work of the implementation.
               * @param cla
               * @param ins
               * @param p1
               * @param p2
               * @param data
               * @param statusList is a list of accepted status code (shorts). [0x9000] by default
               * @return a Promise of response buffer
               */

            }], [{
              key: "create",


              /**
               * create() allows to open the first descriptor available or
               * throw if there is none or if timeout is reached.
               * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)
               * @example
               TransportFoo.create().then(transport => ...)
               */
              value: function create() {
                var _this2 = this;

                var openTimeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3000;
                var listenTimeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10000;

                return new _promise2.default(function (resolve, reject) {
                  var found = false;
                  var listenTimeoutId = setTimeout(function () {
                    sub.unsubscribe();
                    reject(new TransportError(_this2.ErrorMessage_ListenTimeout, "ListenTimeout"));
                  }, listenTimeout);
                  var sub = _this2.listen({
                    next: function next(e) {
                      found = true;
                      sub.unsubscribe();
                      clearTimeout(listenTimeoutId);
                      _this2.open(e.descriptor, openTimeout).then(resolve, reject);
                    },
                    error: function error(e) {
                      clearTimeout(listenTimeoutId);
                      reject(e);
                    },
                    complete: function complete() {
                      clearTimeout(listenTimeoutId);
                      if (!found) {
                        reject(new TransportError(_this2.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
                      }
                    }
                  });
                });
              }
            }]);
            return Transport;
          }();

          Transport.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
          Transport.ErrorMessage_NoDeviceFound = "No Ledger device found";
          exports.default = Transport;

        }).call(this,require("buffer").Buffer)
      },{"babel-runtime/core-js/promise":10,"babel-runtime/helpers/asyncToGenerator":13,"babel-runtime/helpers/classCallCheck":14,"babel-runtime/helpers/createClass":15,"babel-runtime/helpers/toConsumableArray":18,"babel-runtime/regenerator":20,"buffer":24,"events":125}],5:[function(require,module,exports){
        module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
      },{"core-js/library/fn/array/from":25}],6:[function(require,module,exports){
        module.exports = { "default": require("core-js/library/fn/object/create"), __esModule: true };
      },{"core-js/library/fn/object/create":26}],7:[function(require,module,exports){
        module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
      },{"core-js/library/fn/object/define-property":27}],8:[function(require,module,exports){
        module.exports = { "default": require("core-js/library/fn/object/get-prototype-of"), __esModule: true };
      },{"core-js/library/fn/object/get-prototype-of":28}],9:[function(require,module,exports){
        module.exports = { "default": require("core-js/library/fn/object/set-prototype-of"), __esModule: true };
      },{"core-js/library/fn/object/set-prototype-of":29}],10:[function(require,module,exports){
        module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
      },{"core-js/library/fn/promise":30}],11:[function(require,module,exports){
        module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
      },{"core-js/library/fn/symbol":31}],12:[function(require,module,exports){
        module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
      },{"core-js/library/fn/symbol/iterator":32}],13:[function(require,module,exports){
        "use strict";

        exports.__esModule = true;

        var _promise = require("../core-js/promise");

        var _promise2 = _interopRequireDefault(_promise);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        exports.default = function (fn) {
          return function () {
            var gen = fn.apply(this, arguments);
            return new _promise2.default(function (resolve, reject) {
              function step(key, arg) {
                try {
                  var info = gen[key](arg);
                  var value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }

                if (info.done) {
                  resolve(value);
                } else {
                  return _promise2.default.resolve(value).then(function (value) {
                    step("next", value);
                  }, function (err) {
                    step("throw", err);
                  });
                }
              }

              return step("next");
            });
          };
        };
      },{"../core-js/promise":10}],14:[function(require,module,exports){
        "use strict";

        exports.__esModule = true;

        exports.default = function (instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        };
      },{}],15:[function(require,module,exports){
        "use strict";

        exports.__esModule = true;

        var _defineProperty = require("../core-js/object/define-property");

        var _defineProperty2 = _interopRequireDefault(_defineProperty);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        exports.default = function () {
          function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor) descriptor.writable = true;
              (0, _defineProperty2.default)(target, descriptor.key, descriptor);
            }
          }

          return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
          };
        }();
      },{"../core-js/object/define-property":7}],16:[function(require,module,exports){
        "use strict";

        exports.__esModule = true;

        var _setPrototypeOf = require("../core-js/object/set-prototype-of");

        var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);

        var _create = require("../core-js/object/create");

        var _create2 = _interopRequireDefault(_create);

        var _typeof2 = require("../helpers/typeof");

        var _typeof3 = _interopRequireDefault(_typeof2);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        exports.default = function (subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
          }

          subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
        };
      },{"../core-js/object/create":6,"../core-js/object/set-prototype-of":9,"../helpers/typeof":19}],17:[function(require,module,exports){
        "use strict";

        exports.__esModule = true;

        var _typeof2 = require("../helpers/typeof");

        var _typeof3 = _interopRequireDefault(_typeof2);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        exports.default = function (self, call) {
          if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }

          return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
        };
      },{"../helpers/typeof":19}],18:[function(require,module,exports){
        "use strict";

        exports.__esModule = true;

        var _from = require("../core-js/array/from");

        var _from2 = _interopRequireDefault(_from);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        exports.default = function (arr) {
          if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
              arr2[i] = arr[i];
            }

            return arr2;
          } else {
            return (0, _from2.default)(arr);
          }
        };
      },{"../core-js/array/from":5}],19:[function(require,module,exports){
        "use strict";

        exports.__esModule = true;

        var _iterator = require("../core-js/symbol/iterator");

        var _iterator2 = _interopRequireDefault(_iterator);

        var _symbol = require("../core-js/symbol");

        var _symbol2 = _interopRequireDefault(_symbol);

        var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
          return typeof obj === "undefined" ? "undefined" : _typeof(obj);
        } : function (obj) {
          return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
        };
      },{"../core-js/symbol":11,"../core-js/symbol/iterator":12}],20:[function(require,module,exports){
        module.exports = require("regenerator-runtime");

      },{"regenerator-runtime":129}],21:[function(require,module,exports){
        "use strict";

        /**
         * Generate a character map.
         * @param {string} alphabet e.g. "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"
         * @param {object} mappings map overrides from key to value
         * @method
         */

        var charmap = function (alphabet, mappings) {
          mappings || (mappings = {});
          alphabet.split("").forEach(function (c, i) {
            if (!(c in mappings)) mappings[c] = i;
          });
          return mappings;
        }

        /**
         * The RFC 4648 base 32 alphabet and character map.
         * @see {@link https://tools.ietf.org/html/rfc4648}
         */

        var rfc4648 = {
          alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
          charmap: {
            0: 14,
            1: 8
          }
        };

        rfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);

        /**
         * The Crockford base 32 alphabet and character map.
         * @see {@link http://www.crockford.com/wrmg/base32.html}
         */

        var crockford = {
          alphabet: "0123456789ABCDEFGHJKMNPQRSTVWXYZ",
          charmap: {
            O: 0,
            I: 1,
            L: 1
          }
        };

        crockford.charmap = charmap(crockford.alphabet, crockford.charmap);

        /**
         * base32hex
         * @see {@link https://en.wikipedia.org/wiki/Base32#base32hex}
         */

        var base32hex = {
          alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
          charmap: {}
        };

        base32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);

        /**
         * Create a new `Decoder` with the given options.
         *
         * @param {object} [options]
         *   @param {string} [type] Supported Base-32 variants are "rfc4648" and
         *     "crockford".
         *   @param {object} [charmap] Override the character map used in decoding.
         * @constructor
         */

        function Decoder (options) {
          this.buf = [];
          this.shift = 8;
          this.carry = 0;

          if (options) {

            switch (options.type) {
              case "rfc4648":
                this.charmap = exports.rfc4648.charmap;
                break;
              case "crockford":
                this.charmap = exports.crockford.charmap;
                break;
              case "base32hex":
                this.charmap = exports.base32hex.charmap;
                break;
              default:
                throw new Error("invalid type");
            }

            if (options.charmap) this.charmap = options.charmap;
          }
        }

        /**
         * The default character map coresponds to RFC4648.
         */

        Decoder.prototype.charmap = rfc4648.charmap;

        /**
         * Decode a string, continuing from the previous state.
         *
         * @param {string} str
         * @return {Decoder} this
         */

        Decoder.prototype.write = function (str) {
          var charmap = this.charmap;
          var buf = this.buf;
          var shift = this.shift;
          var carry = this.carry;

          // decode string
          str.toUpperCase().split("").forEach(function (char) {

            // ignore padding
            if (char == "=") return;

            // lookup symbol
            var symbol = charmap[char] & 0xff;

            // 1: 00000 000
            // 2:          00 00000 0
            // 3:                    0000 0000
            // 4:                             0 00000 00
            // 5:                                       000 00000
            // 6:                                                00000 000
            // 7:                                                         00 00000 0

            shift -= 5;
            if (shift > 0) {
              carry |= symbol << shift;
            } else if (shift < 0) {
              buf.push(carry | (symbol >> -shift));
              shift += 8;
              carry = (symbol << shift) & 0xff;
            } else {
              buf.push(carry | symbol);
              shift = 8;
              carry = 0;
            }
          });

          // save state
          this.shift = shift;
          this.carry = carry;

          // for chaining
          return this;
        };

        /**
         * Finish decoding.
         *
         * @param {string} [str] The final string to decode.
         * @return {Array} Decoded byte array.
         */

        Decoder.prototype.finalize = function (str) {
          if (str) {
            this.write(str);
          }
          if (this.shift !== 8 && this.carry !== 0) {
            this.buf.push(this.carry);
            this.shift = 8;
            this.carry = 0;
          }
          return this.buf;
        };

        /**
         * Create a new `Encoder` with the given options.
         *
         * @param {object} [options]
         *   @param {string} [type] Supported Base-32 variants are "rfc4648" and
         *     "crockford".
         *   @param {object} [alphabet] Override the alphabet used in encoding.
         * @constructor
         */

        function Encoder (options) {
          this.buf = "";
          this.shift = 3;
          this.carry = 0;

          if (options) {

            switch (options.type) {
              case "rfc4648":
                this.alphabet = exports.rfc4648.alphabet;
                break;
              case "crockford":
                this.alphabet = exports.crockford.alphabet;
                break;
              case "base32hex":
                this.alphabet = exports.base32hex.alphabet;
                break;
              default:
                throw new Error("invalid type");
            }

            if (options.alphabet) this.alphabet = options.alphabet;
            else if (options.lc) this.alphabet = this.alphabet.toLowerCase();
          }
        }

        /**
         * The default alphabet coresponds to RFC4648.
         */

        Encoder.prototype.alphabet = rfc4648.alphabet;

        /**
         * Encode a byte array, continuing from the previous state.
         *
         * @param {byte[]} buf The byte array to encode.
         * @return {Encoder} this
         */

        Encoder.prototype.write = function (buf) {
          var shift = this.shift;
          var carry = this.carry;
          var symbol;
          var byte;
          var i;

          // encode each byte in buf
          for (i = 0; i < buf.length; i++) {
            byte = buf[i];

            // 1: 00000 000
            // 2:          00 00000 0
            // 3:                    0000 0000
            // 4:                             0 00000 00
            // 5:                                       000 00000
            // 6:                                                00000 000
            // 7:                                                         00 00000 0

            symbol = carry | (byte >> shift);
            this.buf += this.alphabet[symbol & 0x1f];

            if (shift > 5) {
              shift -= 5;
              symbol = byte >> shift;
              this.buf += this.alphabet[symbol & 0x1f];
            }

            shift = 5 - shift;
            carry = byte << shift;
            shift = 8 - shift;
          }

          // save state
          this.shift = shift;
          this.carry = carry;

          // for chaining
          return this;
        };

        /**
         * Finish encoding.
         *
         * @param {byte[]} [buf] The final byte array to encode.
         * @return {string} The encoded byte array.
         */

        Encoder.prototype.finalize = function (buf) {
          if (buf) {
            this.write(buf);
          }
          if (this.shift !== 3) {
            this.buf += this.alphabet[this.carry & 0x1f];
            this.shift = 3;
            this.carry = 0;
          }
          return this.buf;
        };

        /**
         * Convenience encoder.
         *
         * @param {byte[]} buf The byte array to encode.
         * @param {object} [options] Options to pass to the encoder.
         * @return {string} The encoded string.
         */

        exports.encode = function (buf, options) {
          return new Encoder(options).finalize(buf);
        };

        /**
         * Convenience decoder.
         *
         * @param {string} str The string to decode.
         * @param {object} [options] Options to pass to the decoder.
         * @return {byte[]} The decoded byte array.
         */

        exports.decode = function (str, options) {
          return new Decoder(options).finalize(str);
        };

// Exports.
        exports.Decoder = Decoder;
        exports.Encoder = Encoder;
        exports.charmap = charmap;
        exports.crockford = crockford;
        exports.rfc4648 = rfc4648;
        exports.base32hex = base32hex;

      },{}],22:[function(require,module,exports){
        'use strict'

        exports.byteLength = byteLength
        exports.toByteArray = toByteArray
        exports.fromByteArray = fromByteArray

        var lookup = []
        var revLookup = []
        var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

        var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
        for (var i = 0, len = code.length; i < len; ++i) {
          lookup[i] = code[i]
          revLookup[code.charCodeAt(i)] = i
        }

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
        revLookup['-'.charCodeAt(0)] = 62
        revLookup['_'.charCodeAt(0)] = 63

        function placeHoldersCount (b64) {
          var len = b64.length
          if (len % 4 > 0) {
            throw new Error('Invalid string. Length must be a multiple of 4')
          }

          // the number of equal signs (place holders)
          // if there are two placeholders, than the two characters before it
          // represent one byte
          // if there is only one, then the three characters before it represent 2 bytes
          // this is just a cheap hack to not do indexOf twice
          return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
        }

        function byteLength (b64) {
          // base64 is 4/3 + up to two characters of the original data
          return (b64.length * 3 / 4) - placeHoldersCount(b64)
        }

        function toByteArray (b64) {
          var i, l, tmp, placeHolders, arr
          var len = b64.length
          placeHolders = placeHoldersCount(b64)

          arr = new Arr((len * 3 / 4) - placeHolders)

          // if there are placeholders, only get up to the last complete 4 chars
          l = placeHolders > 0 ? len - 4 : len

          var L = 0

          for (i = 0; i < l; i += 4) {
            tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
            arr[L++] = (tmp >> 16) & 0xFF
            arr[L++] = (tmp >> 8) & 0xFF
            arr[L++] = tmp & 0xFF
          }

          if (placeHolders === 2) {
            tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
            arr[L++] = tmp & 0xFF
          } else if (placeHolders === 1) {
            tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
            arr[L++] = (tmp >> 8) & 0xFF
            arr[L++] = tmp & 0xFF
          }

          return arr
        }

        function tripletToBase64 (num) {
          return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
        }

        function encodeChunk (uint8, start, end) {
          var tmp
          var output = []
          for (var i = start; i < end; i += 3) {
            tmp = ((uint8[i] << 16) & 0xFF0000) + ((uint8[i + 1] << 8) & 0xFF00) + (uint8[i + 2] & 0xFF)
            output.push(tripletToBase64(tmp))
          }
          return output.join('')
        }

        function fromByteArray (uint8) {
          var tmp
          var len = uint8.length
          var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
          var output = ''
          var parts = []
          var maxChunkLength = 16383 // must be multiple of 3

          // go through the array every three bytes, we'll deal with trailing stuff later
          for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
            parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
          }

          // pad the end with zeros, but make sure to not forget the extra bytes
          if (extraBytes === 1) {
            tmp = uint8[len - 1]
            output += lookup[tmp >> 2]
            output += lookup[(tmp << 4) & 0x3F]
            output += '=='
          } else if (extraBytes === 2) {
            tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
            output += lookup[tmp >> 10]
            output += lookup[(tmp >> 4) & 0x3F]
            output += lookup[(tmp << 2) & 0x3F]
            output += '='
          }

          parts.push(output)

          return parts.join('')
        }

      },{}],23:[function(require,module,exports){

      },{}],24:[function(require,module,exports){
        (function (global){
          /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
          /* eslint-disable no-proto */

          'use strict'

          var base64 = require('base64-js')
          var ieee754 = require('ieee754')
          var isArray = require('isarray')

          exports.Buffer = Buffer
          exports.SlowBuffer = SlowBuffer
          exports.INSPECT_MAX_BYTES = 50

          /**
           * If `Buffer.TYPED_ARRAY_SUPPORT`:
           *   === true    Use Uint8Array implementation (fastest)
           *   === false   Use Object implementation (most compatible, even IE6)
           *
           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
           * Opera 11.6+, iOS 4.2+.
           *
           * Due to various browser bugs, sometimes the Object implementation will be used even
           * when the browser supports typed arrays.
           *
           * Note:
           *
           *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
           *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
           *
           *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
           *
           *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
           *     incorrect length in some situations.

           * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
           * get the Object implementation, which is slower but behaves correctly.
           */
          Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
            ? global.TYPED_ARRAY_SUPPORT
            : typedArraySupport()

          /*
 * Export kMaxLength after typed array support is determined.
 */
          exports.kMaxLength = kMaxLength()

          function typedArraySupport () {
            try {
              var arr = new Uint8Array(1)
              arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
              return arr.foo() === 42 && // typed array instances can be augmented
                typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
                arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
            } catch (e) {
              return false
            }
          }

          function kMaxLength () {
            return Buffer.TYPED_ARRAY_SUPPORT
              ? 0x7fffffff
              : 0x3fffffff
          }

          function createBuffer (that, length) {
            if (kMaxLength() < length) {
              throw new RangeError('Invalid typed array length')
            }
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              // Return an augmented `Uint8Array` instance, for best performance
              that = new Uint8Array(length)
              that.__proto__ = Buffer.prototype
            } else {
              // Fallback: Return an object instance of the Buffer class
              if (that === null) {
                that = new Buffer(length)
              }
              that.length = length
            }

            return that
          }

          /**
           * The Buffer constructor returns instances of `Uint8Array` that have their
           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
           * and the `Uint8Array` methods. Square bracket notation works as expected -- it
           * returns a single octet.
           *
           * The `Uint8Array` prototype remains unmodified.
           */

          function Buffer (arg, encodingOrOffset, length) {
            if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
              return new Buffer(arg, encodingOrOffset, length)
            }

            // Common case.
            if (typeof arg === 'number') {
              if (typeof encodingOrOffset === 'string') {
                throw new Error(
                  'If encoding is specified then the first argument must be a string'
                )
              }
              return allocUnsafe(this, arg)
            }
            return from(this, arg, encodingOrOffset, length)
          }

          Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
          Buffer._augment = function (arr) {
            arr.__proto__ = Buffer.prototype
            return arr
          }

          function from (that, value, encodingOrOffset, length) {
            if (typeof value === 'number') {
              throw new TypeError('"value" argument must not be a number')
            }

            if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
              return fromArrayBuffer(that, value, encodingOrOffset, length)
            }

            if (typeof value === 'string') {
              return fromString(that, value, encodingOrOffset)
            }

            return fromObject(that, value)
          }

          /**
           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
           * if value is a number.
           * Buffer.from(str[, encoding])
           * Buffer.from(array)
           * Buffer.from(buffer)
           * Buffer.from(arrayBuffer[, byteOffset[, length]])
           **/
          Buffer.from = function (value, encodingOrOffset, length) {
            return from(null, value, encodingOrOffset, length)
          }

          if (Buffer.TYPED_ARRAY_SUPPORT) {
            Buffer.prototype.__proto__ = Uint8Array.prototype
            Buffer.__proto__ = Uint8Array
            if (typeof Symbol !== 'undefined' && Symbol.species &&
              Buffer[Symbol.species] === Buffer) {
              // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
              Object.defineProperty(Buffer, Symbol.species, {
                value: null,
                configurable: true
              })
            }
          }

          function assertSize (size) {
            if (typeof size !== 'number') {
              throw new TypeError('"size" argument must be a number')
            } else if (size < 0) {
              throw new RangeError('"size" argument must not be negative')
            }
          }

          function alloc (that, size, fill, encoding) {
            assertSize(size)
            if (size <= 0) {
              return createBuffer(that, size)
            }
            if (fill !== undefined) {
              // Only pay attention to encoding if it's a string. This
              // prevents accidentally sending in a number that would
              // be interpretted as a start offset.
              return typeof encoding === 'string'
                ? createBuffer(that, size).fill(fill, encoding)
                : createBuffer(that, size).fill(fill)
            }
            return createBuffer(that, size)
          }

          /**
           * Creates a new filled Buffer instance.
           * alloc(size[, fill[, encoding]])
           **/
          Buffer.alloc = function (size, fill, encoding) {
            return alloc(null, size, fill, encoding)
          }

          function allocUnsafe (that, size) {
            assertSize(size)
            that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
            if (!Buffer.TYPED_ARRAY_SUPPORT) {
              for (var i = 0; i < size; ++i) {
                that[i] = 0
              }
            }
            return that
          }

          /**
           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
           * */
          Buffer.allocUnsafe = function (size) {
            return allocUnsafe(null, size)
          }
          /**
           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
           */
          Buffer.allocUnsafeSlow = function (size) {
            return allocUnsafe(null, size)
          }

          function fromString (that, string, encoding) {
            if (typeof encoding !== 'string' || encoding === '') {
              encoding = 'utf8'
            }

            if (!Buffer.isEncoding(encoding)) {
              throw new TypeError('"encoding" must be a valid string encoding')
            }

            var length = byteLength(string, encoding) | 0
            that = createBuffer(that, length)

            var actual = that.write(string, encoding)

            if (actual !== length) {
              // Writing a hex string, for example, that contains invalid characters will
              // cause everything after the first invalid character to be ignored. (e.g.
              // 'abxxcd' will be treated as 'ab')
              that = that.slice(0, actual)
            }

            return that
          }

          function fromArrayLike (that, array) {
            var length = array.length < 0 ? 0 : checked(array.length) | 0
            that = createBuffer(that, length)
            for (var i = 0; i < length; i += 1) {
              that[i] = array[i] & 255
            }
            return that
          }

          function fromArrayBuffer (that, array, byteOffset, length) {
            array.byteLength // this throws if `array` is not a valid ArrayBuffer

            if (byteOffset < 0 || array.byteLength < byteOffset) {
              throw new RangeError('\'offset\' is out of bounds')
            }

            if (array.byteLength < byteOffset + (length || 0)) {
              throw new RangeError('\'length\' is out of bounds')
            }

            if (byteOffset === undefined && length === undefined) {
              array = new Uint8Array(array)
            } else if (length === undefined) {
              array = new Uint8Array(array, byteOffset)
            } else {
              array = new Uint8Array(array, byteOffset, length)
            }

            if (Buffer.TYPED_ARRAY_SUPPORT) {
              // Return an augmented `Uint8Array` instance, for best performance
              that = array
              that.__proto__ = Buffer.prototype
            } else {
              // Fallback: Return an object instance of the Buffer class
              that = fromArrayLike(that, array)
            }
            return that
          }

          function fromObject (that, obj) {
            if (Buffer.isBuffer(obj)) {
              var len = checked(obj.length) | 0
              that = createBuffer(that, len)

              if (that.length === 0) {
                return that
              }

              obj.copy(that, 0, 0, len)
              return that
            }

            if (obj) {
              if ((typeof ArrayBuffer !== 'undefined' &&
                  obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
                if (typeof obj.length !== 'number' || isnan(obj.length)) {
                  return createBuffer(that, 0)
                }
                return fromArrayLike(that, obj)
              }

              if (obj.type === 'Buffer' && isArray(obj.data)) {
                return fromArrayLike(that, obj.data)
              }
            }

            throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
          }

          function checked (length) {
            // Note: cannot use `length < kMaxLength()` here because that fails when
            // length is NaN (which is otherwise coerced to zero.)
            if (length >= kMaxLength()) {
              throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                'size: 0x' + kMaxLength().toString(16) + ' bytes')
            }
            return length | 0
          }

          function SlowBuffer (length) {
            if (+length != length) { // eslint-disable-line eqeqeq
              length = 0
            }
            return Buffer.alloc(+length)
          }

          Buffer.isBuffer = function isBuffer (b) {
            return !!(b != null && b._isBuffer)
          }

          Buffer.compare = function compare (a, b) {
            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
              throw new TypeError('Arguments must be Buffers')
            }

            if (a === b) return 0

            var x = a.length
            var y = b.length

            for (var i = 0, len = Math.min(x, y); i < len; ++i) {
              if (a[i] !== b[i]) {
                x = a[i]
                y = b[i]
                break
              }
            }

            if (x < y) return -1
            if (y < x) return 1
            return 0
          }

          Buffer.isEncoding = function isEncoding (encoding) {
            switch (String(encoding).toLowerCase()) {
              case 'hex':
              case 'utf8':
              case 'utf-8':
              case 'ascii':
              case 'latin1':
              case 'binary':
              case 'base64':
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return true
              default:
                return false
            }
          }

          Buffer.concat = function concat (list, length) {
            if (!isArray(list)) {
              throw new TypeError('"list" argument must be an Array of Buffers')
            }

            if (list.length === 0) {
              return Buffer.alloc(0)
            }

            var i
            if (length === undefined) {
              length = 0
              for (i = 0; i < list.length; ++i) {
                length += list[i].length
              }
            }

            var buffer = Buffer.allocUnsafe(length)
            var pos = 0
            for (i = 0; i < list.length; ++i) {
              var buf = list[i]
              if (!Buffer.isBuffer(buf)) {
                throw new TypeError('"list" argument must be an Array of Buffers')
              }
              buf.copy(buffer, pos)
              pos += buf.length
            }
            return buffer
          }

          function byteLength (string, encoding) {
            if (Buffer.isBuffer(string)) {
              return string.length
            }
            if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
              (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
              return string.byteLength
            }
            if (typeof string !== 'string') {
              string = '' + string
            }

            var len = string.length
            if (len === 0) return 0

            // Use a for loop to avoid recursion
            var loweredCase = false
            for (;;) {
              switch (encoding) {
                case 'ascii':
                case 'latin1':
                case 'binary':
                  return len
                case 'utf8':
                case 'utf-8':
                case undefined:
                  return utf8ToBytes(string).length
                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return len * 2
                case 'hex':
                  return len >>> 1
                case 'base64':
                  return base64ToBytes(string).length
                default:
                  if (loweredCase) return utf8ToBytes(string).length // assume utf8
                  encoding = ('' + encoding).toLowerCase()
                  loweredCase = true
              }
            }
          }
          Buffer.byteLength = byteLength

          function slowToString (encoding, start, end) {
            var loweredCase = false

            // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
            // property of a typed array.

            // This behaves neither like String nor Uint8Array in that we set start/end
            // to their upper/lower bounds if the value passed is out of range.
            // undefined is handled specially as per ECMA-262 6th Edition,
            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
            if (start === undefined || start < 0) {
              start = 0
            }
            // Return early if start > this.length. Done here to prevent potential uint32
            // coercion fail below.
            if (start > this.length) {
              return ''
            }

            if (end === undefined || end > this.length) {
              end = this.length
            }

            if (end <= 0) {
              return ''
            }

            // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
            end >>>= 0
            start >>>= 0

            if (end <= start) {
              return ''
            }

            if (!encoding) encoding = 'utf8'

            while (true) {
              switch (encoding) {
                case 'hex':
                  return hexSlice(this, start, end)

                case 'utf8':
                case 'utf-8':
                  return utf8Slice(this, start, end)

                case 'ascii':
                  return asciiSlice(this, start, end)

                case 'latin1':
                case 'binary':
                  return latin1Slice(this, start, end)

                case 'base64':
                  return base64Slice(this, start, end)

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return utf16leSlice(this, start, end)

                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                  encoding = (encoding + '').toLowerCase()
                  loweredCase = true
              }
            }
          }

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
          Buffer.prototype._isBuffer = true

          function swap (b, n, m) {
            var i = b[n]
            b[n] = b[m]
            b[m] = i
          }

          Buffer.prototype.swap16 = function swap16 () {
            var len = this.length
            if (len % 2 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 16-bits')
            }
            for (var i = 0; i < len; i += 2) {
              swap(this, i, i + 1)
            }
            return this
          }

          Buffer.prototype.swap32 = function swap32 () {
            var len = this.length
            if (len % 4 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 32-bits')
            }
            for (var i = 0; i < len; i += 4) {
              swap(this, i, i + 3)
              swap(this, i + 1, i + 2)
            }
            return this
          }

          Buffer.prototype.swap64 = function swap64 () {
            var len = this.length
            if (len % 8 !== 0) {
              throw new RangeError('Buffer size must be a multiple of 64-bits')
            }
            for (var i = 0; i < len; i += 8) {
              swap(this, i, i + 7)
              swap(this, i + 1, i + 6)
              swap(this, i + 2, i + 5)
              swap(this, i + 3, i + 4)
            }
            return this
          }

          Buffer.prototype.toString = function toString () {
            var length = this.length | 0
            if (length === 0) return ''
            if (arguments.length === 0) return utf8Slice(this, 0, length)
            return slowToString.apply(this, arguments)
          }

          Buffer.prototype.equals = function equals (b) {
            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
            if (this === b) return true
            return Buffer.compare(this, b) === 0
          }

          Buffer.prototype.inspect = function inspect () {
            var str = ''
            var max = exports.INSPECT_MAX_BYTES
            if (this.length > 0) {
              str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
              if (this.length > max) str += ' ... '
            }
            return '<Buffer ' + str + '>'
          }

          Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
            if (!Buffer.isBuffer(target)) {
              throw new TypeError('Argument must be a Buffer')
            }

            if (start === undefined) {
              start = 0
            }
            if (end === undefined) {
              end = target ? target.length : 0
            }
            if (thisStart === undefined) {
              thisStart = 0
            }
            if (thisEnd === undefined) {
              thisEnd = this.length
            }

            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
              throw new RangeError('out of range index')
            }

            if (thisStart >= thisEnd && start >= end) {
              return 0
            }
            if (thisStart >= thisEnd) {
              return -1
            }
            if (start >= end) {
              return 1
            }

            start >>>= 0
            end >>>= 0
            thisStart >>>= 0
            thisEnd >>>= 0

            if (this === target) return 0

            var x = thisEnd - thisStart
            var y = end - start
            var len = Math.min(x, y)

            var thisCopy = this.slice(thisStart, thisEnd)
            var targetCopy = target.slice(start, end)

            for (var i = 0; i < len; ++i) {
              if (thisCopy[i] !== targetCopy[i]) {
                x = thisCopy[i]
                y = targetCopy[i]
                break
              }
            }

            if (x < y) return -1
            if (y < x) return 1
            return 0
          }

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
          function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
            // Empty buffer means no match
            if (buffer.length === 0) return -1

            // Normalize byteOffset
            if (typeof byteOffset === 'string') {
              encoding = byteOffset
              byteOffset = 0
            } else if (byteOffset > 0x7fffffff) {
              byteOffset = 0x7fffffff
            } else if (byteOffset < -0x80000000) {
              byteOffset = -0x80000000
            }
            byteOffset = +byteOffset  // Coerce to Number.
            if (isNaN(byteOffset)) {
              // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
              byteOffset = dir ? 0 : (buffer.length - 1)
            }

            // Normalize byteOffset: negative offsets start from the end of the buffer
            if (byteOffset < 0) byteOffset = buffer.length + byteOffset
            if (byteOffset >= buffer.length) {
              if (dir) return -1
              else byteOffset = buffer.length - 1
            } else if (byteOffset < 0) {
              if (dir) byteOffset = 0
              else return -1
            }

            // Normalize val
            if (typeof val === 'string') {
              val = Buffer.from(val, encoding)
            }

            // Finally, search either indexOf (if dir is true) or lastIndexOf
            if (Buffer.isBuffer(val)) {
              // Special case: looking for empty string/buffer always fails
              if (val.length === 0) {
                return -1
              }
              return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
            } else if (typeof val === 'number') {
              val = val & 0xFF // Search for a byte value [0-255]
              if (Buffer.TYPED_ARRAY_SUPPORT &&
                typeof Uint8Array.prototype.indexOf === 'function') {
                if (dir) {
                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
                } else {
                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
                }
              }
              return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
            }

            throw new TypeError('val must be string, number or Buffer')
          }

          function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
            var indexSize = 1
            var arrLength = arr.length
            var valLength = val.length

            if (encoding !== undefined) {
              encoding = String(encoding).toLowerCase()
              if (encoding === 'ucs2' || encoding === 'ucs-2' ||
                encoding === 'utf16le' || encoding === 'utf-16le') {
                if (arr.length < 2 || val.length < 2) {
                  return -1
                }
                indexSize = 2
                arrLength /= 2
                valLength /= 2
                byteOffset /= 2
              }
            }

            function read (buf, i) {
              if (indexSize === 1) {
                return buf[i]
              } else {
                return buf.readUInt16BE(i * indexSize)
              }
            }

            var i
            if (dir) {
              var foundIndex = -1
              for (i = byteOffset; i < arrLength; i++) {
                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                  if (foundIndex === -1) foundIndex = i
                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
                } else {
                  if (foundIndex !== -1) i -= i - foundIndex
                  foundIndex = -1
                }
              }
            } else {
              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
              for (i = byteOffset; i >= 0; i--) {
                var found = true
                for (var j = 0; j < valLength; j++) {
                  if (read(arr, i + j) !== read(val, j)) {
                    found = false
                    break
                  }
                }
                if (found) return i
              }
            }

            return -1
          }

          Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
            return this.indexOf(val, byteOffset, encoding) !== -1
          }

          Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
          }

          Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
            return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
          }

          function hexWrite (buf, string, offset, length) {
            offset = Number(offset) || 0
            var remaining = buf.length - offset
            if (!length) {
              length = remaining
            } else {
              length = Number(length)
              if (length > remaining) {
                length = remaining
              }
            }

            // must be an even number of digits
            var strLen = string.length
            if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

            if (length > strLen / 2) {
              length = strLen / 2
            }
            for (var i = 0; i < length; ++i) {
              var parsed = parseInt(string.substr(i * 2, 2), 16)
              if (isNaN(parsed)) return i
              buf[offset + i] = parsed
            }
            return i
          }

          function utf8Write (buf, string, offset, length) {
            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
          }

          function asciiWrite (buf, string, offset, length) {
            return blitBuffer(asciiToBytes(string), buf, offset, length)
          }

          function latin1Write (buf, string, offset, length) {
            return asciiWrite(buf, string, offset, length)
          }

          function base64Write (buf, string, offset, length) {
            return blitBuffer(base64ToBytes(string), buf, offset, length)
          }

          function ucs2Write (buf, string, offset, length) {
            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
          }

          Buffer.prototype.write = function write (string, offset, length, encoding) {
            // Buffer#write(string)
            if (offset === undefined) {
              encoding = 'utf8'
              length = this.length
              offset = 0
              // Buffer#write(string, encoding)
            } else if (length === undefined && typeof offset === 'string') {
              encoding = offset
              length = this.length
              offset = 0
              // Buffer#write(string, offset[, length][, encoding])
            } else if (isFinite(offset)) {
              offset = offset | 0
              if (isFinite(length)) {
                length = length | 0
                if (encoding === undefined) encoding = 'utf8'
              } else {
                encoding = length
                length = undefined
              }
              // legacy write(string, encoding, offset, length) - remove in v0.13
            } else {
              throw new Error(
                'Buffer.write(string, encoding, offset[, length]) is no longer supported'
              )
            }

            var remaining = this.length - offset
            if (length === undefined || length > remaining) length = remaining

            if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
              throw new RangeError('Attempt to write outside buffer bounds')
            }

            if (!encoding) encoding = 'utf8'

            var loweredCase = false
            for (;;) {
              switch (encoding) {
                case 'hex':
                  return hexWrite(this, string, offset, length)

                case 'utf8':
                case 'utf-8':
                  return utf8Write(this, string, offset, length)

                case 'ascii':
                  return asciiWrite(this, string, offset, length)

                case 'latin1':
                case 'binary':
                  return latin1Write(this, string, offset, length)

                case 'base64':
                  // Warning: maxLength not taken into account in base64Write
                  return base64Write(this, string, offset, length)

                case 'ucs2':
                case 'ucs-2':
                case 'utf16le':
                case 'utf-16le':
                  return ucs2Write(this, string, offset, length)

                default:
                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
                  encoding = ('' + encoding).toLowerCase()
                  loweredCase = true
              }
            }
          }

          Buffer.prototype.toJSON = function toJSON () {
            return {
              type: 'Buffer',
              data: Array.prototype.slice.call(this._arr || this, 0)
            }
          }

          function base64Slice (buf, start, end) {
            if (start === 0 && end === buf.length) {
              return base64.fromByteArray(buf)
            } else {
              return base64.fromByteArray(buf.slice(start, end))
            }
          }

          function utf8Slice (buf, start, end) {
            end = Math.min(buf.length, end)
            var res = []

            var i = start
            while (i < end) {
              var firstByte = buf[i]
              var codePoint = null
              var bytesPerSequence = (firstByte > 0xEF) ? 4
                : (firstByte > 0xDF) ? 3
                  : (firstByte > 0xBF) ? 2
                    : 1

              if (i + bytesPerSequence <= end) {
                var secondByte, thirdByte, fourthByte, tempCodePoint

                switch (bytesPerSequence) {
                  case 1:
                    if (firstByte < 0x80) {
                      codePoint = firstByte
                    }
                    break
                  case 2:
                    secondByte = buf[i + 1]
                    if ((secondByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                      if (tempCodePoint > 0x7F) {
                        codePoint = tempCodePoint
                      }
                    }
                    break
                  case 3:
                    secondByte = buf[i + 1]
                    thirdByte = buf[i + 2]
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                        codePoint = tempCodePoint
                      }
                    }
                    break
                  case 4:
                    secondByte = buf[i + 1]
                    thirdByte = buf[i + 2]
                    fourthByte = buf[i + 3]
                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                        codePoint = tempCodePoint
                      }
                    }
                }
              }

              if (codePoint === null) {
                // we did not generate a valid codePoint so insert a
                // replacement char (U+FFFD) and advance only 1 byte
                codePoint = 0xFFFD
                bytesPerSequence = 1
              } else if (codePoint > 0xFFFF) {
                // encode to utf16 (surrogate pair dance)
                codePoint -= 0x10000
                res.push(codePoint >>> 10 & 0x3FF | 0xD800)
                codePoint = 0xDC00 | codePoint & 0x3FF
              }

              res.push(codePoint)
              i += bytesPerSequence
            }

            return decodeCodePointsArray(res)
          }

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
          var MAX_ARGUMENTS_LENGTH = 0x1000

          function decodeCodePointsArray (codePoints) {
            var len = codePoints.length
            if (len <= MAX_ARGUMENTS_LENGTH) {
              return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
            }

            // Decode in chunks to avoid "call stack size exceeded".
            var res = ''
            var i = 0
            while (i < len) {
              res += String.fromCharCode.apply(
                String,
                codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
              )
            }
            return res
          }

          function asciiSlice (buf, start, end) {
            var ret = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i] & 0x7F)
            }
            return ret
          }

          function latin1Slice (buf, start, end) {
            var ret = ''
            end = Math.min(buf.length, end)

            for (var i = start; i < end; ++i) {
              ret += String.fromCharCode(buf[i])
            }
            return ret
          }

          function hexSlice (buf, start, end) {
            var len = buf.length

            if (!start || start < 0) start = 0
            if (!end || end < 0 || end > len) end = len

            var out = ''
            for (var i = start; i < end; ++i) {
              out += toHex(buf[i])
            }
            return out
          }

          function utf16leSlice (buf, start, end) {
            var bytes = buf.slice(start, end)
            var res = ''
            for (var i = 0; i < bytes.length; i += 2) {
              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
            }
            return res
          }

          Buffer.prototype.slice = function slice (start, end) {
            var len = this.length
            start = ~~start
            end = end === undefined ? len : ~~end

            if (start < 0) {
              start += len
              if (start < 0) start = 0
            } else if (start > len) {
              start = len
            }

            if (end < 0) {
              end += len
              if (end < 0) end = 0
            } else if (end > len) {
              end = len
            }

            if (end < start) end = start

            var newBuf
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              newBuf = this.subarray(start, end)
              newBuf.__proto__ = Buffer.prototype
            } else {
              var sliceLen = end - start
              newBuf = new Buffer(sliceLen, undefined)
              for (var i = 0; i < sliceLen; ++i) {
                newBuf[i] = this[i + start]
              }
            }

            return newBuf
          }

          /*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
          function checkOffset (offset, ext, length) {
            if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
          }

          Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var val = this[offset]
            var mul = 1
            var i = 0
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul
            }

            return val
          }

          Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) {
              checkOffset(offset, byteLength, this.length)
            }

            var val = this[offset + --byteLength]
            var mul = 1
            while (byteLength > 0 && (mul *= 0x100)) {
              val += this[offset + --byteLength] * mul
            }

            return val
          }

          Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length)
            return this[offset]
          }

          Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length)
            return this[offset] | (this[offset + 1] << 8)
          }

          Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length)
            return (this[offset] << 8) | this[offset + 1]
          }

          Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)

            return ((this[offset]) |
              (this[offset + 1] << 8) |
              (this[offset + 2] << 16)) +
              (this[offset + 3] * 0x1000000)
          }

          Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (this[offset] * 0x1000000) +
              ((this[offset + 1] << 16) |
                (this[offset + 2] << 8) |
                this[offset + 3])
          }

          Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var val = this[offset]
            var mul = 1
            var i = 0
            while (++i < byteLength && (mul *= 0x100)) {
              val += this[offset + i] * mul
            }
            mul *= 0x80

            if (val >= mul) val -= Math.pow(2, 8 * byteLength)

            return val
          }

          Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) checkOffset(offset, byteLength, this.length)

            var i = byteLength
            var mul = 1
            var val = this[offset + --i]
            while (i > 0 && (mul *= 0x100)) {
              val += this[offset + --i] * mul
            }
            mul *= 0x80

            if (val >= mul) val -= Math.pow(2, 8 * byteLength)

            return val
          }

          Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 1, this.length)
            if (!(this[offset] & 0x80)) return (this[offset])
            return ((0xff - this[offset] + 1) * -1)
          }

          Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length)
            var val = this[offset] | (this[offset + 1] << 8)
            return (val & 0x8000) ? val | 0xFFFF0000 : val
          }

          Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 2, this.length)
            var val = this[offset + 1] | (this[offset] << 8)
            return (val & 0x8000) ? val | 0xFFFF0000 : val
          }

          Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (this[offset]) |
              (this[offset + 1] << 8) |
              (this[offset + 2] << 16) |
              (this[offset + 3] << 24)
          }

          Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)

            return (this[offset] << 24) |
              (this[offset + 1] << 16) |
              (this[offset + 2] << 8) |
              (this[offset + 3])
          }

          Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)
            return ieee754.read(this, offset, true, 23, 4)
          }

          Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 4, this.length)
            return ieee754.read(this, offset, false, 23, 4)
          }

          Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length)
            return ieee754.read(this, offset, true, 52, 8)
          }

          Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
            if (!noAssert) checkOffset(offset, 8, this.length)
            return ieee754.read(this, offset, false, 52, 8)
          }

          function checkInt (buf, value, offset, ext, max, min) {
            if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
            if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
            if (offset + ext > buf.length) throw new RangeError('Index out of range')
          }

          Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1
              checkInt(this, value, offset, byteLength, maxBytes, 0)
            }

            var mul = 1
            var i = 0
            this[offset] = value & 0xFF
            while (++i < byteLength && (mul *= 0x100)) {
              this[offset + i] = (value / mul) & 0xFF
            }

            return offset + byteLength
          }

          Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset | 0
            byteLength = byteLength | 0
            if (!noAssert) {
              var maxBytes = Math.pow(2, 8 * byteLength) - 1
              checkInt(this, value, offset, byteLength, maxBytes, 0)
            }

            var i = byteLength - 1
            var mul = 1
            this[offset + i] = value & 0xFF
            while (--i >= 0 && (mul *= 0x100)) {
              this[offset + i] = (value / mul) & 0xFF
            }

            return offset + byteLength
          }

          Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
            this[offset] = (value & 0xff)
            return offset + 1
          }

          function objectWriteUInt16 (buf, value, offset, littleEndian) {
            if (value < 0) value = 0xffff + value + 1
            for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
              buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
                (littleEndian ? i : 1 - i) * 8
            }
          }

          Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = (value & 0xff)
              this[offset + 1] = (value >>> 8)
            } else {
              objectWriteUInt16(this, value, offset, true)
            }
            return offset + 2
          }

          Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = (value >>> 8)
              this[offset + 1] = (value & 0xff)
            } else {
              objectWriteUInt16(this, value, offset, false)
            }
            return offset + 2
          }

          function objectWriteUInt32 (buf, value, offset, littleEndian) {
            if (value < 0) value = 0xffffffff + value + 1
            for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
              buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
            }
          }

          Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset + 3] = (value >>> 24)
              this[offset + 2] = (value >>> 16)
              this[offset + 1] = (value >>> 8)
              this[offset] = (value & 0xff)
            } else {
              objectWriteUInt32(this, value, offset, true)
            }
            return offset + 4
          }

          Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = (value >>> 24)
              this[offset + 1] = (value >>> 16)
              this[offset + 2] = (value >>> 8)
              this[offset + 3] = (value & 0xff)
            } else {
              objectWriteUInt32(this, value, offset, false)
            }
            return offset + 4
          }

          Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1)

              checkInt(this, value, offset, byteLength, limit - 1, -limit)
            }

            var i = 0
            var mul = 1
            var sub = 0
            this[offset] = value & 0xFF
            while (++i < byteLength && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                sub = 1
              }
              this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
            }

            return offset + byteLength
          }

          Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) {
              var limit = Math.pow(2, 8 * byteLength - 1)

              checkInt(this, value, offset, byteLength, limit - 1, -limit)
            }

            var i = byteLength - 1
            var mul = 1
            var sub = 0
            this[offset + i] = value & 0xFF
            while (--i >= 0 && (mul *= 0x100)) {
              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                sub = 1
              }
              this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
            }

            return offset + byteLength
          }

          Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
            if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
            if (value < 0) value = 0xff + value + 1
            this[offset] = (value & 0xff)
            return offset + 1
          }

          Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = (value & 0xff)
              this[offset + 1] = (value >>> 8)
            } else {
              objectWriteUInt16(this, value, offset, true)
            }
            return offset + 2
          }

          Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = (value >>> 8)
              this[offset + 1] = (value & 0xff)
            } else {
              objectWriteUInt16(this, value, offset, false)
            }
            return offset + 2
          }

          Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = (value & 0xff)
              this[offset + 1] = (value >>> 8)
              this[offset + 2] = (value >>> 16)
              this[offset + 3] = (value >>> 24)
            } else {
              objectWriteUInt32(this, value, offset, true)
            }
            return offset + 4
          }

          Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
            value = +value
            offset = offset | 0
            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
            if (value < 0) value = 0xffffffff + value + 1
            if (Buffer.TYPED_ARRAY_SUPPORT) {
              this[offset] = (value >>> 24)
              this[offset + 1] = (value >>> 16)
              this[offset + 2] = (value >>> 8)
              this[offset + 3] = (value & 0xff)
            } else {
              objectWriteUInt32(this, value, offset, false)
            }
            return offset + 4
          }

          function checkIEEE754 (buf, value, offset, ext, max, min) {
            if (offset + ext > buf.length) throw new RangeError('Index out of range')
            if (offset < 0) throw new RangeError('Index out of range')
          }

          function writeFloat (buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
            }
            ieee754.write(buf, value, offset, littleEndian, 23, 4)
            return offset + 4
          }

          Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
            return writeFloat(this, value, offset, true, noAssert)
          }

          Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
            return writeFloat(this, value, offset, false, noAssert)
          }

          function writeDouble (buf, value, offset, littleEndian, noAssert) {
            if (!noAssert) {
              checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
            }
            ieee754.write(buf, value, offset, littleEndian, 52, 8)
            return offset + 8
          }

          Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
            return writeDouble(this, value, offset, true, noAssert)
          }

          Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
            return writeDouble(this, value, offset, false, noAssert)
          }

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
          Buffer.prototype.copy = function copy (target, targetStart, start, end) {
            if (!start) start = 0
            if (!end && end !== 0) end = this.length
            if (targetStart >= target.length) targetStart = target.length
            if (!targetStart) targetStart = 0
            if (end > 0 && end < start) end = start

            // Copy 0 bytes; we're done
            if (end === start) return 0
            if (target.length === 0 || this.length === 0) return 0

            // Fatal error conditions
            if (targetStart < 0) {
              throw new RangeError('targetStart out of bounds')
            }
            if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
            if (end < 0) throw new RangeError('sourceEnd out of bounds')

            // Are we oob?
            if (end > this.length) end = this.length
            if (target.length - targetStart < end - start) {
              end = target.length - targetStart + start
            }

            var len = end - start
            var i

            if (this === target && start < targetStart && targetStart < end) {
              // descending copy from end
              for (i = len - 1; i >= 0; --i) {
                target[i + targetStart] = this[i + start]
              }
            } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
              // ascending copy from start
              for (i = 0; i < len; ++i) {
                target[i + targetStart] = this[i + start]
              }
            } else {
              Uint8Array.prototype.set.call(
                target,
                this.subarray(start, start + len),
                targetStart
              )
            }

            return len
          }

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
          Buffer.prototype.fill = function fill (val, start, end, encoding) {
            // Handle string cases:
            if (typeof val === 'string') {
              if (typeof start === 'string') {
                encoding = start
                start = 0
                end = this.length
              } else if (typeof end === 'string') {
                encoding = end
                end = this.length
              }
              if (val.length === 1) {
                var code = val.charCodeAt(0)
                if (code < 256) {
                  val = code
                }
              }
              if (encoding !== undefined && typeof encoding !== 'string') {
                throw new TypeError('encoding must be a string')
              }
              if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
                throw new TypeError('Unknown encoding: ' + encoding)
              }
            } else if (typeof val === 'number') {
              val = val & 255
            }

            // Invalid ranges are not set to a default, so can range check early.
            if (start < 0 || this.length < start || this.length < end) {
              throw new RangeError('Out of range index')
            }

            if (end <= start) {
              return this
            }

            start = start >>> 0
            end = end === undefined ? this.length : end >>> 0

            if (!val) val = 0

            var i
            if (typeof val === 'number') {
              for (i = start; i < end; ++i) {
                this[i] = val
              }
            } else {
              var bytes = Buffer.isBuffer(val)
                ? val
                : utf8ToBytes(new Buffer(val, encoding).toString())
              var len = bytes.length
              for (i = 0; i < end - start; ++i) {
                this[i + start] = bytes[i % len]
              }
            }

            return this
          }

// HELPER FUNCTIONS
// ================

          var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

          function base64clean (str) {
            // Node strips out invalid characters like \n and \t from the string, base64-js does not
            str = stringtrim(str).replace(INVALID_BASE64_RE, '')
            // Node converts strings with length < 2 to ''
            if (str.length < 2) return ''
            // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
            while (str.length % 4 !== 0) {
              str = str + '='
            }
            return str
          }

          function stringtrim (str) {
            if (str.trim) return str.trim()
            return str.replace(/^\s+|\s+$/g, '')
          }

          function toHex (n) {
            if (n < 16) return '0' + n.toString(16)
            return n.toString(16)
          }

          function utf8ToBytes (string, units) {
            units = units || Infinity
            var codePoint
            var length = string.length
            var leadSurrogate = null
            var bytes = []

            for (var i = 0; i < length; ++i) {
              codePoint = string.charCodeAt(i)

              // is surrogate component
              if (codePoint > 0xD7FF && codePoint < 0xE000) {
                // last char was a lead
                if (!leadSurrogate) {
                  // no lead yet
                  if (codePoint > 0xDBFF) {
                    // unexpected trail
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                    continue
                  } else if (i + 1 === length) {
                    // unpaired lead
                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                    continue
                  }

                  // valid lead
                  leadSurrogate = codePoint

                  continue
                }

                // 2 leads in a row
                if (codePoint < 0xDC00) {
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
                  leadSurrogate = codePoint
                  continue
                }

                // valid surrogate pair
                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
              } else if (leadSurrogate) {
                // valid bmp char, but last char was a lead
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              }

              leadSurrogate = null

              // encode utf8
              if (codePoint < 0x80) {
                if ((units -= 1) < 0) break
                bytes.push(codePoint)
              } else if (codePoint < 0x800) {
                if ((units -= 2) < 0) break
                bytes.push(
                  codePoint >> 0x6 | 0xC0,
                  codePoint & 0x3F | 0x80
                )
              } else if (codePoint < 0x10000) {
                if ((units -= 3) < 0) break
                bytes.push(
                  codePoint >> 0xC | 0xE0,
                  codePoint >> 0x6 & 0x3F | 0x80,
                  codePoint & 0x3F | 0x80
                )
              } else if (codePoint < 0x110000) {
                if ((units -= 4) < 0) break
                bytes.push(
                  codePoint >> 0x12 | 0xF0,
                  codePoint >> 0xC & 0x3F | 0x80,
                  codePoint >> 0x6 & 0x3F | 0x80,
                  codePoint & 0x3F | 0x80
                )
              } else {
                throw new Error('Invalid code point')
              }
            }

            return bytes
          }

          function asciiToBytes (str) {
            var byteArray = []
            for (var i = 0; i < str.length; ++i) {
              // Node's code seems to be doing this and not & 0x7F..
              byteArray.push(str.charCodeAt(i) & 0xFF)
            }
            return byteArray
          }

          function utf16leToBytes (str, units) {
            var c, hi, lo
            var byteArray = []
            for (var i = 0; i < str.length; ++i) {
              if ((units -= 2) < 0) break

              c = str.charCodeAt(i)
              hi = c >> 8
              lo = c % 256
              byteArray.push(lo)
              byteArray.push(hi)
            }

            return byteArray
          }

          function base64ToBytes (str) {
            return base64.toByteArray(base64clean(str))
          }

          function blitBuffer (src, dst, offset, length) {
            for (var i = 0; i < length; ++i) {
              if ((i + offset >= dst.length) || (i >= src.length)) break
              dst[i + offset] = src[i]
            }
            return i
          }

          function isnan (val) {
            return val !== val // eslint-disable-line no-self-compare
          }

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
      },{"base64-js":22,"ieee754":126,"isarray":128}],25:[function(require,module,exports){
        require('../../modules/es6.string.iterator');
        require('../../modules/es6.array.from');
        module.exports = require('../../modules/_core').Array.from;

      },{"../../modules/_core":40,"../../modules/es6.array.from":107,"../../modules/es6.string.iterator":115}],26:[function(require,module,exports){
        require('../../modules/es6.object.create');
        var $Object = require('../../modules/_core').Object;
        module.exports = function create(P, D) {
          return $Object.create(P, D);
        };

      },{"../../modules/_core":40,"../../modules/es6.object.create":109}],27:[function(require,module,exports){
        require('../../modules/es6.object.define-property');
        var $Object = require('../../modules/_core').Object;
        module.exports = function defineProperty(it, key, desc) {
          return $Object.defineProperty(it, key, desc);
        };

      },{"../../modules/_core":40,"../../modules/es6.object.define-property":110}],28:[function(require,module,exports){
        require('../../modules/es6.object.get-prototype-of');
        module.exports = require('../../modules/_core').Object.getPrototypeOf;

      },{"../../modules/_core":40,"../../modules/es6.object.get-prototype-of":111}],29:[function(require,module,exports){
        require('../../modules/es6.object.set-prototype-of');
        module.exports = require('../../modules/_core').Object.setPrototypeOf;

      },{"../../modules/_core":40,"../../modules/es6.object.set-prototype-of":112}],30:[function(require,module,exports){
        require('../modules/es6.object.to-string');
        require('../modules/es6.string.iterator');
        require('../modules/web.dom.iterable');
        require('../modules/es6.promise');
        require('../modules/es7.promise.finally');
        require('../modules/es7.promise.try');
        module.exports = require('../modules/_core').Promise;

      },{"../modules/_core":40,"../modules/es6.object.to-string":113,"../modules/es6.promise":114,"../modules/es6.string.iterator":115,"../modules/es7.promise.finally":117,"../modules/es7.promise.try":118,"../modules/web.dom.iterable":121}],31:[function(require,module,exports){
        require('../../modules/es6.symbol');
        require('../../modules/es6.object.to-string');
        require('../../modules/es7.symbol.async-iterator');
        require('../../modules/es7.symbol.observable');
        module.exports = require('../../modules/_core').Symbol;

      },{"../../modules/_core":40,"../../modules/es6.object.to-string":113,"../../modules/es6.symbol":116,"../../modules/es7.symbol.async-iterator":119,"../../modules/es7.symbol.observable":120}],32:[function(require,module,exports){
        require('../../modules/es6.string.iterator');
        require('../../modules/web.dom.iterable');
        module.exports = require('../../modules/_wks-ext').f('iterator');

      },{"../../modules/_wks-ext":104,"../../modules/es6.string.iterator":115,"../../modules/web.dom.iterable":121}],33:[function(require,module,exports){
        module.exports = function (it) {
          if (typeof it != 'function') throw TypeError(it + ' is not a function!');
          return it;
        };

      },{}],34:[function(require,module,exports){
        module.exports = function () { /* empty */ };

      },{}],35:[function(require,module,exports){
        module.exports = function (it, Constructor, name, forbiddenField) {
          if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
            throw TypeError(name + ': incorrect invocation!');
          } return it;
        };

      },{}],36:[function(require,module,exports){
        var isObject = require('./_is-object');
        module.exports = function (it) {
          if (!isObject(it)) throw TypeError(it + ' is not an object!');
          return it;
        };

      },{"./_is-object":60}],37:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
        var toIObject = require('./_to-iobject');
        var toLength = require('./_to-length');
        var toAbsoluteIndex = require('./_to-absolute-index');
        module.exports = function (IS_INCLUDES) {
          return function ($this, el, fromIndex) {
            var O = toIObject($this);
            var length = toLength(O.length);
            var index = toAbsoluteIndex(fromIndex, length);
            var value;
            // Array#includes uses SameValueZero equality algorithm
            // eslint-disable-next-line no-self-compare
            if (IS_INCLUDES && el != el) while (length > index) {
              value = O[index++];
              // eslint-disable-next-line no-self-compare
              if (value != value) return true;
              // Array#indexOf ignores holes, Array#includes - not
            } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
              if (O[index] === el) return IS_INCLUDES || index || 0;
            } return !IS_INCLUDES && -1;
          };
        };

      },{"./_to-absolute-index":96,"./_to-iobject":98,"./_to-length":99}],38:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
        var cof = require('./_cof');
        var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
        var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
        var tryGet = function (it, key) {
          try {
            return it[key];
          } catch (e) { /* empty */ }
        };

        module.exports = function (it) {
          var O, T, B;
          return it === undefined ? 'Undefined' : it === null ? 'Null'
            // @@toStringTag case
            : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
              // builtinTag case
              : ARG ? cof(O)
                // ES3 arguments fallback
                : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
        };

      },{"./_cof":39,"./_wks":105}],39:[function(require,module,exports){
        var toString = {}.toString;

        module.exports = function (it) {
          return toString.call(it).slice(8, -1);
        };

      },{}],40:[function(require,module,exports){
        var core = module.exports = { version: '2.5.3' };
        if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

      },{}],41:[function(require,module,exports){
        'use strict';
        var $defineProperty = require('./_object-dp');
        var createDesc = require('./_property-desc');

        module.exports = function (object, index, value) {
          if (index in object) $defineProperty.f(object, index, createDesc(0, value));
          else object[index] = value;
        };

      },{"./_object-dp":72,"./_property-desc":85}],42:[function(require,module,exports){
// optional / simple context binding
        var aFunction = require('./_a-function');
        module.exports = function (fn, that, length) {
          aFunction(fn);
          if (that === undefined) return fn;
          switch (length) {
            case 1: return function (a) {
              return fn.call(that, a);
            };
            case 2: return function (a, b) {
              return fn.call(that, a, b);
            };
            case 3: return function (a, b, c) {
              return fn.call(that, a, b, c);
            };
          }
          return function (/* ...args */) {
            return fn.apply(that, arguments);
          };
        };

      },{"./_a-function":33}],43:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
        module.exports = function (it) {
          if (it == undefined) throw TypeError("Can't call method on  " + it);
          return it;
        };

      },{}],44:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
        module.exports = !require('./_fails')(function () {
          return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
        });

      },{"./_fails":49}],45:[function(require,module,exports){
        var isObject = require('./_is-object');
        var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
        var is = isObject(document) && isObject(document.createElement);
        module.exports = function (it) {
          return is ? document.createElement(it) : {};
        };

      },{"./_global":51,"./_is-object":60}],46:[function(require,module,exports){
// IE 8- don't enum bug keys
        module.exports = (
          'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
        ).split(',');

      },{}],47:[function(require,module,exports){
// all enumerable object keys, includes symbols
        var getKeys = require('./_object-keys');
        var gOPS = require('./_object-gops');
        var pIE = require('./_object-pie');
        module.exports = function (it) {
          var result = getKeys(it);
          var getSymbols = gOPS.f;
          if (getSymbols) {
            var symbols = getSymbols(it);
            var isEnum = pIE.f;
            var i = 0;
            var key;
            while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
          } return result;
        };

      },{"./_object-gops":77,"./_object-keys":80,"./_object-pie":81}],48:[function(require,module,exports){
        var global = require('./_global');
        var core = require('./_core');
        var ctx = require('./_ctx');
        var hide = require('./_hide');
        var PROTOTYPE = 'prototype';

        var $export = function (type, name, source) {
          var IS_FORCED = type & $export.F;
          var IS_GLOBAL = type & $export.G;
          var IS_STATIC = type & $export.S;
          var IS_PROTO = type & $export.P;
          var IS_BIND = type & $export.B;
          var IS_WRAP = type & $export.W;
          var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
          var expProto = exports[PROTOTYPE];
          var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
          var key, own, out;
          if (IS_GLOBAL) source = name;
          for (key in source) {
            // contains in native
            own = !IS_FORCED && target && target[key] !== undefined;
            if (own && key in exports) continue;
            // export native or passed
            out = own ? target[key] : source[key];
            // prevent global pollution for namespaces
            exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
              // bind timers to global for call from export context
              : IS_BIND && own ? ctx(out, global)
                // wrap global constructors for prevent change them in library
                : IS_WRAP && target[key] == out ? (function (C) {
                  var F = function (a, b, c) {
                    if (this instanceof C) {
                      switch (arguments.length) {
                        case 0: return new C();
                        case 1: return new C(a);
                        case 2: return new C(a, b);
                      } return new C(a, b, c);
                    } return C.apply(this, arguments);
                  };
                  F[PROTOTYPE] = C[PROTOTYPE];
                  return F;
                  // make static versions for prototype methods
                })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
            // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
            if (IS_PROTO) {
              (exports.virtual || (exports.virtual = {}))[key] = out;
              // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
              if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
            }
          }
        };
// type bitmap
        $export.F = 1;   // forced
        $export.G = 2;   // global
        $export.S = 4;   // static
        $export.P = 8;   // proto
        $export.B = 16;  // bind
        $export.W = 32;  // wrap
        $export.U = 64;  // safe
        $export.R = 128; // real proto method for `library`
        module.exports = $export;

      },{"./_core":40,"./_ctx":42,"./_global":51,"./_hide":53}],49:[function(require,module,exports){
        module.exports = function (exec) {
          try {
            return !!exec();
          } catch (e) {
            return true;
          }
        };

      },{}],50:[function(require,module,exports){
        var ctx = require('./_ctx');
        var call = require('./_iter-call');
        var isArrayIter = require('./_is-array-iter');
        var anObject = require('./_an-object');
        var toLength = require('./_to-length');
        var getIterFn = require('./core.get-iterator-method');
        var BREAK = {};
        var RETURN = {};
        var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
          var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
          var f = ctx(fn, that, entries ? 2 : 1);
          var index = 0;
          var length, step, iterator, result;
          if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
          // fast case for arrays with default iterator
          if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
            result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
            if (result === BREAK || result === RETURN) return result;
          } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
            result = call(iterator, f, step.value, entries);
            if (result === BREAK || result === RETURN) return result;
          }
        };
        exports.BREAK = BREAK;
        exports.RETURN = RETURN;

      },{"./_an-object":36,"./_ctx":42,"./_is-array-iter":58,"./_iter-call":61,"./_to-length":99,"./core.get-iterator-method":106}],51:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
        var global = module.exports = typeof window != 'undefined' && window.Math == Math
          ? window : typeof self != 'undefined' && self.Math == Math ? self
            // eslint-disable-next-line no-new-func
            : Function('return this')();
        if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

      },{}],52:[function(require,module,exports){
        var hasOwnProperty = {}.hasOwnProperty;
        module.exports = function (it, key) {
          return hasOwnProperty.call(it, key);
        };

      },{}],53:[function(require,module,exports){
        var dP = require('./_object-dp');
        var createDesc = require('./_property-desc');
        module.exports = require('./_descriptors') ? function (object, key, value) {
          return dP.f(object, key, createDesc(1, value));
        } : function (object, key, value) {
          object[key] = value;
          return object;
        };

      },{"./_descriptors":44,"./_object-dp":72,"./_property-desc":85}],54:[function(require,module,exports){
        var document = require('./_global').document;
        module.exports = document && document.documentElement;

      },{"./_global":51}],55:[function(require,module,exports){
        module.exports = !require('./_descriptors') && !require('./_fails')(function () {
          return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
        });

      },{"./_descriptors":44,"./_dom-create":45,"./_fails":49}],56:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
        module.exports = function (fn, args, that) {
          var un = that === undefined;
          switch (args.length) {
            case 0: return un ? fn()
              : fn.call(that);
            case 1: return un ? fn(args[0])
              : fn.call(that, args[0]);
            case 2: return un ? fn(args[0], args[1])
              : fn.call(that, args[0], args[1]);
            case 3: return un ? fn(args[0], args[1], args[2])
              : fn.call(that, args[0], args[1], args[2]);
            case 4: return un ? fn(args[0], args[1], args[2], args[3])
              : fn.call(that, args[0], args[1], args[2], args[3]);
          } return fn.apply(that, args);
        };

      },{}],57:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
        var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
        module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
          return cof(it) == 'String' ? it.split('') : Object(it);
        };

      },{"./_cof":39}],58:[function(require,module,exports){
// check on default Array iterator
        var Iterators = require('./_iterators');
        var ITERATOR = require('./_wks')('iterator');
        var ArrayProto = Array.prototype;

        module.exports = function (it) {
          return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
        };

      },{"./_iterators":66,"./_wks":105}],59:[function(require,module,exports){
// 7.2.2 IsArray(argument)
        var cof = require('./_cof');
        module.exports = Array.isArray || function isArray(arg) {
          return cof(arg) == 'Array';
        };

      },{"./_cof":39}],60:[function(require,module,exports){
        module.exports = function (it) {
          return typeof it === 'object' ? it !== null : typeof it === 'function';
        };

      },{}],61:[function(require,module,exports){
// call something on iterator step with safe closing on error
        var anObject = require('./_an-object');
        module.exports = function (iterator, fn, value, entries) {
          try {
            return entries ? fn(anObject(value)[0], value[1]) : fn(value);
            // 7.4.6 IteratorClose(iterator, completion)
          } catch (e) {
            var ret = iterator['return'];
            if (ret !== undefined) anObject(ret.call(iterator));
            throw e;
          }
        };

      },{"./_an-object":36}],62:[function(require,module,exports){
        'use strict';
        var create = require('./_object-create');
        var descriptor = require('./_property-desc');
        var setToStringTag = require('./_set-to-string-tag');
        var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
        require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

        module.exports = function (Constructor, NAME, next) {
          Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
          setToStringTag(Constructor, NAME + ' Iterator');
        };

      },{"./_hide":53,"./_object-create":71,"./_property-desc":85,"./_set-to-string-tag":90,"./_wks":105}],63:[function(require,module,exports){
        'use strict';
        var LIBRARY = require('./_library');
        var $export = require('./_export');
        var redefine = require('./_redefine');
        var hide = require('./_hide');
        var has = require('./_has');
        var Iterators = require('./_iterators');
        var $iterCreate = require('./_iter-create');
        var setToStringTag = require('./_set-to-string-tag');
        var getPrototypeOf = require('./_object-gpo');
        var ITERATOR = require('./_wks')('iterator');
        var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
        var FF_ITERATOR = '@@iterator';
        var KEYS = 'keys';
        var VALUES = 'values';

        var returnThis = function () { return this; };

        module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
          $iterCreate(Constructor, NAME, next);
          var getMethod = function (kind) {
            if (!BUGGY && kind in proto) return proto[kind];
            switch (kind) {
              case KEYS: return function keys() { return new Constructor(this, kind); };
              case VALUES: return function values() { return new Constructor(this, kind); };
            } return function entries() { return new Constructor(this, kind); };
          };
          var TAG = NAME + ' Iterator';
          var DEF_VALUES = DEFAULT == VALUES;
          var VALUES_BUG = false;
          var proto = Base.prototype;
          var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
          var $default = (!BUGGY && $native) || getMethod(DEFAULT);
          var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
          var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
          var methods, key, IteratorPrototype;
          // Fix native
          if ($anyNative) {
            IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
            if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
              // Set @@toStringTag to native iterators
              setToStringTag(IteratorPrototype, TAG, true);
              // fix for some old engines
              if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
            }
          }
          // fix Array#{values, @@iterator}.name in V8 / FF
          if (DEF_VALUES && $native && $native.name !== VALUES) {
            VALUES_BUG = true;
            $default = function values() { return $native.call(this); };
          }
          // Define iterator
          if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
            hide(proto, ITERATOR, $default);
          }
          // Plug for library
          Iterators[NAME] = $default;
          Iterators[TAG] = returnThis;
          if (DEFAULT) {
            methods = {
              values: DEF_VALUES ? $default : getMethod(VALUES),
              keys: IS_SET ? $default : getMethod(KEYS),
              entries: $entries
            };
            if (FORCED) for (key in methods) {
              if (!(key in proto)) redefine(proto, key, methods[key]);
            } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
          }
          return methods;
        };

      },{"./_export":48,"./_has":52,"./_hide":53,"./_iter-create":62,"./_iterators":66,"./_library":67,"./_object-gpo":78,"./_redefine":87,"./_set-to-string-tag":90,"./_wks":105}],64:[function(require,module,exports){
        var ITERATOR = require('./_wks')('iterator');
        var SAFE_CLOSING = false;

        try {
          var riter = [7][ITERATOR]();
          riter['return'] = function () { SAFE_CLOSING = true; };
          // eslint-disable-next-line no-throw-literal
          Array.from(riter, function () { throw 2; });
        } catch (e) { /* empty */ }

        module.exports = function (exec, skipClosing) {
          if (!skipClosing && !SAFE_CLOSING) return false;
          var safe = false;
          try {
            var arr = [7];
            var iter = arr[ITERATOR]();
            iter.next = function () { return { done: safe = true }; };
            arr[ITERATOR] = function () { return iter; };
            exec(arr);
          } catch (e) { /* empty */ }
          return safe;
        };

      },{"./_wks":105}],65:[function(require,module,exports){
        module.exports = function (done, value) {
          return { value: value, done: !!done };
        };

      },{}],66:[function(require,module,exports){
        module.exports = {};

      },{}],67:[function(require,module,exports){
        module.exports = true;

      },{}],68:[function(require,module,exports){
        var META = require('./_uid')('meta');
        var isObject = require('./_is-object');
        var has = require('./_has');
        var setDesc = require('./_object-dp').f;
        var id = 0;
        var isExtensible = Object.isExtensible || function () {
          return true;
        };
        var FREEZE = !require('./_fails')(function () {
          return isExtensible(Object.preventExtensions({}));
        });
        var setMeta = function (it) {
          setDesc(it, META, { value: {
            i: 'O' + ++id, // object ID
            w: {}          // weak collections IDs
          } });
        };
        var fastKey = function (it, create) {
          // return primitive with prefix
          if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
          if (!has(it, META)) {
            // can't set metadata to uncaught frozen object
            if (!isExtensible(it)) return 'F';
            // not necessary to add metadata
            if (!create) return 'E';
            // add missing metadata
            setMeta(it);
            // return object ID
          } return it[META].i;
        };
        var getWeak = function (it, create) {
          if (!has(it, META)) {
            // can't set metadata to uncaught frozen object
            if (!isExtensible(it)) return true;
            // not necessary to add metadata
            if (!create) return false;
            // add missing metadata
            setMeta(it);
            // return hash weak collections IDs
          } return it[META].w;
        };
// add metadata on freeze-family methods calling
        var onFreeze = function (it) {
          if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
          return it;
        };
        var meta = module.exports = {
          KEY: META,
          NEED: false,
          fastKey: fastKey,
          getWeak: getWeak,
          onFreeze: onFreeze
        };

      },{"./_fails":49,"./_has":52,"./_is-object":60,"./_object-dp":72,"./_uid":102}],69:[function(require,module,exports){
        var global = require('./_global');
        var macrotask = require('./_task').set;
        var Observer = global.MutationObserver || global.WebKitMutationObserver;
        var process = global.process;
        var Promise = global.Promise;
        var isNode = require('./_cof')(process) == 'process';

        module.exports = function () {
          var head, last, notify;

          var flush = function () {
            var parent, fn;
            if (isNode && (parent = process.domain)) parent.exit();
            while (head) {
              fn = head.fn;
              head = head.next;
              try {
                fn();
              } catch (e) {
                if (head) notify();
                else last = undefined;
                throw e;
              }
            } last = undefined;
            if (parent) parent.enter();
          };

          // Node.js
          if (isNode) {
            notify = function () {
              process.nextTick(flush);
            };
            // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
          } else if (Observer && !(global.navigator && global.navigator.standalone)) {
            var toggle = true;
            var node = document.createTextNode('');
            new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
            notify = function () {
              node.data = toggle = !toggle;
            };
            // environments with maybe non-completely correct, but existent Promise
          } else if (Promise && Promise.resolve) {
            var promise = Promise.resolve();
            notify = function () {
              promise.then(flush);
            };
            // for other environments - macrotask based on:
            // - setImmediate
            // - MessageChannel
            // - window.postMessag
            // - onreadystatechange
            // - setTimeout
          } else {
            notify = function () {
              // strange IE + webpack dev server bug - use .call(global)
              macrotask.call(global, flush);
            };
          }

          return function (fn) {
            var task = { fn: fn, next: undefined };
            if (last) last.next = task;
            if (!head) {
              head = task;
              notify();
            } last = task;
          };
        };

      },{"./_cof":39,"./_global":51,"./_task":95}],70:[function(require,module,exports){
        'use strict';
// 25.4.1.5 NewPromiseCapability(C)
        var aFunction = require('./_a-function');

        function PromiseCapability(C) {
          var resolve, reject;
          this.promise = new C(function ($$resolve, $$reject) {
            if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
            resolve = $$resolve;
            reject = $$reject;
          });
          this.resolve = aFunction(resolve);
          this.reject = aFunction(reject);
        }

        module.exports.f = function (C) {
          return new PromiseCapability(C);
        };

      },{"./_a-function":33}],71:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        var anObject = require('./_an-object');
        var dPs = require('./_object-dps');
        var enumBugKeys = require('./_enum-bug-keys');
        var IE_PROTO = require('./_shared-key')('IE_PROTO');
        var Empty = function () { /* empty */ };
        var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
        var createDict = function () {
          // Thrash, waste and sodomy: IE GC bug
          var iframe = require('./_dom-create')('iframe');
          var i = enumBugKeys.length;
          var lt = '<';
          var gt = '>';
          var iframeDocument;
          iframe.style.display = 'none';
          require('./_html').appendChild(iframe);
          iframe.src = 'javascript:'; // eslint-disable-line no-script-url
          // createDict = iframe.contentWindow.Object;
          // html.removeChild(iframe);
          iframeDocument = iframe.contentWindow.document;
          iframeDocument.open();
          iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
          iframeDocument.close();
          createDict = iframeDocument.F;
          while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
          return createDict();
        };

        module.exports = Object.create || function create(O, Properties) {
          var result;
          if (O !== null) {
            Empty[PROTOTYPE] = anObject(O);
            result = new Empty();
            Empty[PROTOTYPE] = null;
            // add "__proto__" for Object.getPrototypeOf polyfill
            result[IE_PROTO] = O;
          } else result = createDict();
          return Properties === undefined ? result : dPs(result, Properties);
        };

      },{"./_an-object":36,"./_dom-create":45,"./_enum-bug-keys":46,"./_html":54,"./_object-dps":73,"./_shared-key":91}],72:[function(require,module,exports){
        var anObject = require('./_an-object');
        var IE8_DOM_DEFINE = require('./_ie8-dom-define');
        var toPrimitive = require('./_to-primitive');
        var dP = Object.defineProperty;

        exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
          anObject(O);
          P = toPrimitive(P, true);
          anObject(Attributes);
          if (IE8_DOM_DEFINE) try {
            return dP(O, P, Attributes);
          } catch (e) { /* empty */ }
          if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
          if ('value' in Attributes) O[P] = Attributes.value;
          return O;
        };

      },{"./_an-object":36,"./_descriptors":44,"./_ie8-dom-define":55,"./_to-primitive":101}],73:[function(require,module,exports){
        var dP = require('./_object-dp');
        var anObject = require('./_an-object');
        var getKeys = require('./_object-keys');

        module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
          anObject(O);
          var keys = getKeys(Properties);
          var length = keys.length;
          var i = 0;
          var P;
          while (length > i) dP.f(O, P = keys[i++], Properties[P]);
          return O;
        };

      },{"./_an-object":36,"./_descriptors":44,"./_object-dp":72,"./_object-keys":80}],74:[function(require,module,exports){
        var pIE = require('./_object-pie');
        var createDesc = require('./_property-desc');
        var toIObject = require('./_to-iobject');
        var toPrimitive = require('./_to-primitive');
        var has = require('./_has');
        var IE8_DOM_DEFINE = require('./_ie8-dom-define');
        var gOPD = Object.getOwnPropertyDescriptor;

        exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
          O = toIObject(O);
          P = toPrimitive(P, true);
          if (IE8_DOM_DEFINE) try {
            return gOPD(O, P);
          } catch (e) { /* empty */ }
          if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
        };

      },{"./_descriptors":44,"./_has":52,"./_ie8-dom-define":55,"./_object-pie":81,"./_property-desc":85,"./_to-iobject":98,"./_to-primitive":101}],75:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
        var toIObject = require('./_to-iobject');
        var gOPN = require('./_object-gopn').f;
        var toString = {}.toString;

        var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
          ? Object.getOwnPropertyNames(window) : [];

        var getWindowNames = function (it) {
          try {
            return gOPN(it);
          } catch (e) {
            return windowNames.slice();
          }
        };

        module.exports.f = function getOwnPropertyNames(it) {
          return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
        };

      },{"./_object-gopn":76,"./_to-iobject":98}],76:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
        var $keys = require('./_object-keys-internal');
        var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

        exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
          return $keys(O, hiddenKeys);
        };

      },{"./_enum-bug-keys":46,"./_object-keys-internal":79}],77:[function(require,module,exports){
        exports.f = Object.getOwnPropertySymbols;

      },{}],78:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
        var has = require('./_has');
        var toObject = require('./_to-object');
        var IE_PROTO = require('./_shared-key')('IE_PROTO');
        var ObjectProto = Object.prototype;

        module.exports = Object.getPrototypeOf || function (O) {
          O = toObject(O);
          if (has(O, IE_PROTO)) return O[IE_PROTO];
          if (typeof O.constructor == 'function' && O instanceof O.constructor) {
            return O.constructor.prototype;
          } return O instanceof Object ? ObjectProto : null;
        };

      },{"./_has":52,"./_shared-key":91,"./_to-object":100}],79:[function(require,module,exports){
        var has = require('./_has');
        var toIObject = require('./_to-iobject');
        var arrayIndexOf = require('./_array-includes')(false);
        var IE_PROTO = require('./_shared-key')('IE_PROTO');

        module.exports = function (object, names) {
          var O = toIObject(object);
          var i = 0;
          var result = [];
          var key;
          for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
          // Don't enum bug & hidden keys
          while (names.length > i) if (has(O, key = names[i++])) {
            ~arrayIndexOf(result, key) || result.push(key);
          }
          return result;
        };

      },{"./_array-includes":37,"./_has":52,"./_shared-key":91,"./_to-iobject":98}],80:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
        var $keys = require('./_object-keys-internal');
        var enumBugKeys = require('./_enum-bug-keys');

        module.exports = Object.keys || function keys(O) {
          return $keys(O, enumBugKeys);
        };

      },{"./_enum-bug-keys":46,"./_object-keys-internal":79}],81:[function(require,module,exports){
        exports.f = {}.propertyIsEnumerable;

      },{}],82:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
        var $export = require('./_export');
        var core = require('./_core');
        var fails = require('./_fails');
        module.exports = function (KEY, exec) {
          var fn = (core.Object || {})[KEY] || Object[KEY];
          var exp = {};
          exp[KEY] = exec(fn);
          $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
        };

      },{"./_core":40,"./_export":48,"./_fails":49}],83:[function(require,module,exports){
        module.exports = function (exec) {
          try {
            return { e: false, v: exec() };
          } catch (e) {
            return { e: true, v: e };
          }
        };

      },{}],84:[function(require,module,exports){
        var anObject = require('./_an-object');
        var isObject = require('./_is-object');
        var newPromiseCapability = require('./_new-promise-capability');

        module.exports = function (C, x) {
          anObject(C);
          if (isObject(x) && x.constructor === C) return x;
          var promiseCapability = newPromiseCapability.f(C);
          var resolve = promiseCapability.resolve;
          resolve(x);
          return promiseCapability.promise;
        };

      },{"./_an-object":36,"./_is-object":60,"./_new-promise-capability":70}],85:[function(require,module,exports){
        module.exports = function (bitmap, value) {
          return {
            enumerable: !(bitmap & 1),
            configurable: !(bitmap & 2),
            writable: !(bitmap & 4),
            value: value
          };
        };

      },{}],86:[function(require,module,exports){
        var hide = require('./_hide');
        module.exports = function (target, src, safe) {
          for (var key in src) {
            if (safe && target[key]) target[key] = src[key];
            else hide(target, key, src[key]);
          } return target;
        };

      },{"./_hide":53}],87:[function(require,module,exports){
        module.exports = require('./_hide');

      },{"./_hide":53}],88:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
        /* eslint-disable no-proto */
        var isObject = require('./_is-object');
        var anObject = require('./_an-object');
        var check = function (O, proto) {
          anObject(O);
          if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
        };
        module.exports = {
          set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
            function (test, buggy, set) {
              try {
                set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
                set(test, []);
                buggy = !(test instanceof Array);
              } catch (e) { buggy = true; }
              return function setPrototypeOf(O, proto) {
                check(O, proto);
                if (buggy) O.__proto__ = proto;
                else set(O, proto);
                return O;
              };
            }({}, false) : undefined),
          check: check
        };

      },{"./_an-object":36,"./_ctx":42,"./_is-object":60,"./_object-gopd":74}],89:[function(require,module,exports){
        'use strict';
        var global = require('./_global');
        var core = require('./_core');
        var dP = require('./_object-dp');
        var DESCRIPTORS = require('./_descriptors');
        var SPECIES = require('./_wks')('species');

        module.exports = function (KEY) {
          var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
          if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
            configurable: true,
            get: function () { return this; }
          });
        };

      },{"./_core":40,"./_descriptors":44,"./_global":51,"./_object-dp":72,"./_wks":105}],90:[function(require,module,exports){
        var def = require('./_object-dp').f;
        var has = require('./_has');
        var TAG = require('./_wks')('toStringTag');

        module.exports = function (it, tag, stat) {
          if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
        };

      },{"./_has":52,"./_object-dp":72,"./_wks":105}],91:[function(require,module,exports){
        var shared = require('./_shared')('keys');
        var uid = require('./_uid');
        module.exports = function (key) {
          return shared[key] || (shared[key] = uid(key));
        };

      },{"./_shared":92,"./_uid":102}],92:[function(require,module,exports){
        var global = require('./_global');
        var SHARED = '__core-js_shared__';
        var store = global[SHARED] || (global[SHARED] = {});
        module.exports = function (key) {
          return store[key] || (store[key] = {});
        };

      },{"./_global":51}],93:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
        var anObject = require('./_an-object');
        var aFunction = require('./_a-function');
        var SPECIES = require('./_wks')('species');
        module.exports = function (O, D) {
          var C = anObject(O).constructor;
          var S;
          return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
        };

      },{"./_a-function":33,"./_an-object":36,"./_wks":105}],94:[function(require,module,exports){
        var toInteger = require('./_to-integer');
        var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
        module.exports = function (TO_STRING) {
          return function (that, pos) {
            var s = String(defined(that));
            var i = toInteger(pos);
            var l = s.length;
            var a, b;
            if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
            a = s.charCodeAt(i);
            return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
              ? TO_STRING ? s.charAt(i) : a
              : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
          };
        };

      },{"./_defined":43,"./_to-integer":97}],95:[function(require,module,exports){
        var ctx = require('./_ctx');
        var invoke = require('./_invoke');
        var html = require('./_html');
        var cel = require('./_dom-create');
        var global = require('./_global');
        var process = global.process;
        var setTask = global.setImmediate;
        var clearTask = global.clearImmediate;
        var MessageChannel = global.MessageChannel;
        var Dispatch = global.Dispatch;
        var counter = 0;
        var queue = {};
        var ONREADYSTATECHANGE = 'onreadystatechange';
        var defer, channel, port;
        var run = function () {
          var id = +this;
          // eslint-disable-next-line no-prototype-builtins
          if (queue.hasOwnProperty(id)) {
            var fn = queue[id];
            delete queue[id];
            fn();
          }
        };
        var listener = function (event) {
          run.call(event.data);
        };
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
        if (!setTask || !clearTask) {
          setTask = function setImmediate(fn) {
            var args = [];
            var i = 1;
            while (arguments.length > i) args.push(arguments[i++]);
            queue[++counter] = function () {
              // eslint-disable-next-line no-new-func
              invoke(typeof fn == 'function' ? fn : Function(fn), args);
            };
            defer(counter);
            return counter;
          };
          clearTask = function clearImmediate(id) {
            delete queue[id];
          };
          // Node.js 0.8-
          if (require('./_cof')(process) == 'process') {
            defer = function (id) {
              process.nextTick(ctx(run, id, 1));
            };
            // Sphere (JS game engine) Dispatch API
          } else if (Dispatch && Dispatch.now) {
            defer = function (id) {
              Dispatch.now(ctx(run, id, 1));
            };
            // Browsers with MessageChannel, includes WebWorkers
          } else if (MessageChannel) {
            channel = new MessageChannel();
            port = channel.port2;
            channel.port1.onmessage = listener;
            defer = ctx(port.postMessage, port, 1);
            // Browsers with postMessage, skip WebWorkers
            // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
          } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
            defer = function (id) {
              global.postMessage(id + '', '*');
            };
            global.addEventListener('message', listener, false);
            // IE8-
          } else if (ONREADYSTATECHANGE in cel('script')) {
            defer = function (id) {
              html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
                html.removeChild(this);
                run.call(id);
              };
            };
            // Rest old browsers
          } else {
            defer = function (id) {
              setTimeout(ctx(run, id, 1), 0);
            };
          }
        }
        module.exports = {
          set: setTask,
          clear: clearTask
        };

      },{"./_cof":39,"./_ctx":42,"./_dom-create":45,"./_global":51,"./_html":54,"./_invoke":56}],96:[function(require,module,exports){
        var toInteger = require('./_to-integer');
        var max = Math.max;
        var min = Math.min;
        module.exports = function (index, length) {
          index = toInteger(index);
          return index < 0 ? max(index + length, 0) : min(index, length);
        };

      },{"./_to-integer":97}],97:[function(require,module,exports){
// 7.1.4 ToInteger
        var ceil = Math.ceil;
        var floor = Math.floor;
        module.exports = function (it) {
          return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
        };

      },{}],98:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
        var IObject = require('./_iobject');
        var defined = require('./_defined');
        module.exports = function (it) {
          return IObject(defined(it));
        };

      },{"./_defined":43,"./_iobject":57}],99:[function(require,module,exports){
// 7.1.15 ToLength
        var toInteger = require('./_to-integer');
        var min = Math.min;
        module.exports = function (it) {
          return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
        };

      },{"./_to-integer":97}],100:[function(require,module,exports){
// 7.1.13 ToObject(argument)
        var defined = require('./_defined');
        module.exports = function (it) {
          return Object(defined(it));
        };

      },{"./_defined":43}],101:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
        var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
        module.exports = function (it, S) {
          if (!isObject(it)) return it;
          var fn, val;
          if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
          if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
          if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
          throw TypeError("Can't convert object to primitive value");
        };

      },{"./_is-object":60}],102:[function(require,module,exports){
        var id = 0;
        var px = Math.random();
        module.exports = function (key) {
          return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
        };

      },{}],103:[function(require,module,exports){
        var global = require('./_global');
        var core = require('./_core');
        var LIBRARY = require('./_library');
        var wksExt = require('./_wks-ext');
        var defineProperty = require('./_object-dp').f;
        module.exports = function (name) {
          var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
          if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
        };

      },{"./_core":40,"./_global":51,"./_library":67,"./_object-dp":72,"./_wks-ext":104}],104:[function(require,module,exports){
        exports.f = require('./_wks');

      },{"./_wks":105}],105:[function(require,module,exports){
        var store = require('./_shared')('wks');
        var uid = require('./_uid');
        var Symbol = require('./_global').Symbol;
        var USE_SYMBOL = typeof Symbol == 'function';

        var $exports = module.exports = function (name) {
          return store[name] || (store[name] =
            USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
        };

        $exports.store = store;

      },{"./_global":51,"./_shared":92,"./_uid":102}],106:[function(require,module,exports){
        var classof = require('./_classof');
        var ITERATOR = require('./_wks')('iterator');
        var Iterators = require('./_iterators');
        module.exports = require('./_core').getIteratorMethod = function (it) {
          if (it != undefined) return it[ITERATOR]
            || it['@@iterator']
            || Iterators[classof(it)];
        };

      },{"./_classof":38,"./_core":40,"./_iterators":66,"./_wks":105}],107:[function(require,module,exports){
        'use strict';
        var ctx = require('./_ctx');
        var $export = require('./_export');
        var toObject = require('./_to-object');
        var call = require('./_iter-call');
        var isArrayIter = require('./_is-array-iter');
        var toLength = require('./_to-length');
        var createProperty = require('./_create-property');
        var getIterFn = require('./core.get-iterator-method');

        $export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
          // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
          from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
            var O = toObject(arrayLike);
            var C = typeof this == 'function' ? this : Array;
            var aLen = arguments.length;
            var mapfn = aLen > 1 ? arguments[1] : undefined;
            var mapping = mapfn !== undefined;
            var index = 0;
            var iterFn = getIterFn(O);
            var length, result, step, iterator;
            if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
            // if object isn't iterable or it's array with default iterator - use simple case
            if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
              for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
                createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
              }
            } else {
              length = toLength(O.length);
              for (result = new C(length); length > index; index++) {
                createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
              }
            }
            result.length = index;
            return result;
          }
        });

      },{"./_create-property":41,"./_ctx":42,"./_export":48,"./_is-array-iter":58,"./_iter-call":61,"./_iter-detect":64,"./_to-length":99,"./_to-object":100,"./core.get-iterator-method":106}],108:[function(require,module,exports){
        'use strict';
        var addToUnscopables = require('./_add-to-unscopables');
        var step = require('./_iter-step');
        var Iterators = require('./_iterators');
        var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
        module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
          this._t = toIObject(iterated); // target
          this._i = 0;                   // next index
          this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
        }, function () {
          var O = this._t;
          var kind = this._k;
          var index = this._i++;
          if (!O || index >= O.length) {
            this._t = undefined;
            return step(1);
          }
          if (kind == 'keys') return step(0, index);
          if (kind == 'values') return step(0, O[index]);
          return step(0, [index, O[index]]);
        }, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
        Iterators.Arguments = Iterators.Array;

        addToUnscopables('keys');
        addToUnscopables('values');
        addToUnscopables('entries');

      },{"./_add-to-unscopables":34,"./_iter-define":63,"./_iter-step":65,"./_iterators":66,"./_to-iobject":98}],109:[function(require,module,exports){
        var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
        $export($export.S, 'Object', { create: require('./_object-create') });

      },{"./_export":48,"./_object-create":71}],110:[function(require,module,exports){
        var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
        $export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

      },{"./_descriptors":44,"./_export":48,"./_object-dp":72}],111:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
        var toObject = require('./_to-object');
        var $getPrototypeOf = require('./_object-gpo');

        require('./_object-sap')('getPrototypeOf', function () {
          return function getPrototypeOf(it) {
            return $getPrototypeOf(toObject(it));
          };
        });

      },{"./_object-gpo":78,"./_object-sap":82,"./_to-object":100}],112:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
        var $export = require('./_export');
        $export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

      },{"./_export":48,"./_set-proto":88}],113:[function(require,module,exports){
        arguments[4][23][0].apply(exports,arguments)
      },{"dup":23}],114:[function(require,module,exports){
        'use strict';
        var LIBRARY = require('./_library');
        var global = require('./_global');
        var ctx = require('./_ctx');
        var classof = require('./_classof');
        var $export = require('./_export');
        var isObject = require('./_is-object');
        var aFunction = require('./_a-function');
        var anInstance = require('./_an-instance');
        var forOf = require('./_for-of');
        var speciesConstructor = require('./_species-constructor');
        var task = require('./_task').set;
        var microtask = require('./_microtask')();
        var newPromiseCapabilityModule = require('./_new-promise-capability');
        var perform = require('./_perform');
        var promiseResolve = require('./_promise-resolve');
        var PROMISE = 'Promise';
        var TypeError = global.TypeError;
        var process = global.process;
        var $Promise = global[PROMISE];
        var isNode = classof(process) == 'process';
        var empty = function () { /* empty */ };
        var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
        var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

        var USE_NATIVE = !!function () {
          try {
            // correct subclassing with @@species support
            var promise = $Promise.resolve(1);
            var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
              exec(empty, empty);
            };
            // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
            return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
          } catch (e) { /* empty */ }
        }();

// helpers
        var isThenable = function (it) {
          var then;
          return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
        };
        var notify = function (promise, isReject) {
          if (promise._n) return;
          promise._n = true;
          var chain = promise._c;
          microtask(function () {
            var value = promise._v;
            var ok = promise._s == 1;
            var i = 0;
            var run = function (reaction) {
              var handler = ok ? reaction.ok : reaction.fail;
              var resolve = reaction.resolve;
              var reject = reaction.reject;
              var domain = reaction.domain;
              var result, then;
              try {
                if (handler) {
                  if (!ok) {
                    if (promise._h == 2) onHandleUnhandled(promise);
                    promise._h = 1;
                  }
                  if (handler === true) result = value;
                  else {
                    if (domain) domain.enter();
                    result = handler(value);
                    if (domain) domain.exit();
                  }
                  if (result === reaction.promise) {
                    reject(TypeError('Promise-chain cycle'));
                  } else if (then = isThenable(result)) {
                    then.call(result, resolve, reject);
                  } else resolve(result);
                } else reject(value);
              } catch (e) {
                reject(e);
              }
            };
            while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
            promise._c = [];
            promise._n = false;
            if (isReject && !promise._h) onUnhandled(promise);
          });
        };
        var onUnhandled = function (promise) {
          task.call(global, function () {
            var value = promise._v;
            var unhandled = isUnhandled(promise);
            var result, handler, console;
            if (unhandled) {
              result = perform(function () {
                if (isNode) {
                  process.emit('unhandledRejection', value, promise);
                } else if (handler = global.onunhandledrejection) {
                  handler({ promise: promise, reason: value });
                } else if ((console = global.console) && console.error) {
                  console.error('Unhandled promise rejection', value);
                }
              });
              // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
              promise._h = isNode || isUnhandled(promise) ? 2 : 1;
            } promise._a = undefined;
            if (unhandled && result.e) throw result.v;
          });
        };
        var isUnhandled = function (promise) {
          return promise._h !== 1 && (promise._a || promise._c).length === 0;
        };
        var onHandleUnhandled = function (promise) {
          task.call(global, function () {
            var handler;
            if (isNode) {
              process.emit('rejectionHandled', promise);
            } else if (handler = global.onrejectionhandled) {
              handler({ promise: promise, reason: promise._v });
            }
          });
        };
        var $reject = function (value) {
          var promise = this;
          if (promise._d) return;
          promise._d = true;
          promise = promise._w || promise; // unwrap
          promise._v = value;
          promise._s = 2;
          if (!promise._a) promise._a = promise._c.slice();
          notify(promise, true);
        };
        var $resolve = function (value) {
          var promise = this;
          var then;
          if (promise._d) return;
          promise._d = true;
          promise = promise._w || promise; // unwrap
          try {
            if (promise === value) throw TypeError("Promise can't be resolved itself");
            if (then = isThenable(value)) {
              microtask(function () {
                var wrapper = { _w: promise, _d: false }; // wrap
                try {
                  then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
                } catch (e) {
                  $reject.call(wrapper, e);
                }
              });
            } else {
              promise._v = value;
              promise._s = 1;
              notify(promise, false);
            }
          } catch (e) {
            $reject.call({ _w: promise, _d: false }, e); // wrap
          }
        };

// constructor polyfill
        if (!USE_NATIVE) {
          // 25.4.3.1 Promise(executor)
          $Promise = function Promise(executor) {
            anInstance(this, $Promise, PROMISE, '_h');
            aFunction(executor);
            Internal.call(this);
            try {
              executor(ctx($resolve, this, 1), ctx($reject, this, 1));
            } catch (err) {
              $reject.call(this, err);
            }
          };
          // eslint-disable-next-line no-unused-vars
          Internal = function Promise(executor) {
            this._c = [];             // <- awaiting reactions
            this._a = undefined;      // <- checked in isUnhandled reactions
            this._s = 0;              // <- state
            this._d = false;          // <- done
            this._v = undefined;      // <- value
            this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
            this._n = false;          // <- notify
          };
          Internal.prototype = require('./_redefine-all')($Promise.prototype, {
            // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
            then: function then(onFulfilled, onRejected) {
              var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
              reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
              reaction.fail = typeof onRejected == 'function' && onRejected;
              reaction.domain = isNode ? process.domain : undefined;
              this._c.push(reaction);
              if (this._a) this._a.push(reaction);
              if (this._s) notify(this, false);
              return reaction.promise;
            },
            // 25.4.5.1 Promise.prototype.catch(onRejected)
            'catch': function (onRejected) {
              return this.then(undefined, onRejected);
            }
          });
          OwnPromiseCapability = function () {
            var promise = new Internal();
            this.promise = promise;
            this.resolve = ctx($resolve, promise, 1);
            this.reject = ctx($reject, promise, 1);
          };
          newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
            return C === $Promise || C === Wrapper
              ? new OwnPromiseCapability(C)
              : newGenericPromiseCapability(C);
          };
        }

        $export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
        require('./_set-to-string-tag')($Promise, PROMISE);
        require('./_set-species')(PROMISE);
        Wrapper = require('./_core')[PROMISE];

// statics
        $export($export.S + $export.F * !USE_NATIVE, PROMISE, {
          // 25.4.4.5 Promise.reject(r)
          reject: function reject(r) {
            var capability = newPromiseCapability(this);
            var $$reject = capability.reject;
            $$reject(r);
            return capability.promise;
          }
        });
        $export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
          // 25.4.4.6 Promise.resolve(x)
          resolve: function resolve(x) {
            return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
          }
        });
        $export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
          $Promise.all(iter)['catch'](empty);
        })), PROMISE, {
          // 25.4.4.1 Promise.all(iterable)
          all: function all(iterable) {
            var C = this;
            var capability = newPromiseCapability(C);
            var resolve = capability.resolve;
            var reject = capability.reject;
            var result = perform(function () {
              var values = [];
              var index = 0;
              var remaining = 1;
              forOf(iterable, false, function (promise) {
                var $index = index++;
                var alreadyCalled = false;
                values.push(undefined);
                remaining++;
                C.resolve(promise).then(function (value) {
                  if (alreadyCalled) return;
                  alreadyCalled = true;
                  values[$index] = value;
                  --remaining || resolve(values);
                }, reject);
              });
              --remaining || resolve(values);
            });
            if (result.e) reject(result.v);
            return capability.promise;
          },
          // 25.4.4.4 Promise.race(iterable)
          race: function race(iterable) {
            var C = this;
            var capability = newPromiseCapability(C);
            var reject = capability.reject;
            var result = perform(function () {
              forOf(iterable, false, function (promise) {
                C.resolve(promise).then(capability.resolve, reject);
              });
            });
            if (result.e) reject(result.v);
            return capability.promise;
          }
        });

      },{"./_a-function":33,"./_an-instance":35,"./_classof":38,"./_core":40,"./_ctx":42,"./_export":48,"./_for-of":50,"./_global":51,"./_is-object":60,"./_iter-detect":64,"./_library":67,"./_microtask":69,"./_new-promise-capability":70,"./_perform":83,"./_promise-resolve":84,"./_redefine-all":86,"./_set-species":89,"./_set-to-string-tag":90,"./_species-constructor":93,"./_task":95,"./_wks":105}],115:[function(require,module,exports){
        'use strict';
        var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
        require('./_iter-define')(String, 'String', function (iterated) {
          this._t = String(iterated); // target
          this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
        }, function () {
          var O = this._t;
          var index = this._i;
          var point;
          if (index >= O.length) return { value: undefined, done: true };
          point = $at(O, index);
          this._i += point.length;
          return { value: point, done: false };
        });

      },{"./_iter-define":63,"./_string-at":94}],116:[function(require,module,exports){
        'use strict';
// ECMAScript 6 symbols shim
        var global = require('./_global');
        var has = require('./_has');
        var DESCRIPTORS = require('./_descriptors');
        var $export = require('./_export');
        var redefine = require('./_redefine');
        var META = require('./_meta').KEY;
        var $fails = require('./_fails');
        var shared = require('./_shared');
        var setToStringTag = require('./_set-to-string-tag');
        var uid = require('./_uid');
        var wks = require('./_wks');
        var wksExt = require('./_wks-ext');
        var wksDefine = require('./_wks-define');
        var enumKeys = require('./_enum-keys');
        var isArray = require('./_is-array');
        var anObject = require('./_an-object');
        var isObject = require('./_is-object');
        var toIObject = require('./_to-iobject');
        var toPrimitive = require('./_to-primitive');
        var createDesc = require('./_property-desc');
        var _create = require('./_object-create');
        var gOPNExt = require('./_object-gopn-ext');
        var $GOPD = require('./_object-gopd');
        var $DP = require('./_object-dp');
        var $keys = require('./_object-keys');
        var gOPD = $GOPD.f;
        var dP = $DP.f;
        var gOPN = gOPNExt.f;
        var $Symbol = global.Symbol;
        var $JSON = global.JSON;
        var _stringify = $JSON && $JSON.stringify;
        var PROTOTYPE = 'prototype';
        var HIDDEN = wks('_hidden');
        var TO_PRIMITIVE = wks('toPrimitive');
        var isEnum = {}.propertyIsEnumerable;
        var SymbolRegistry = shared('symbol-registry');
        var AllSymbols = shared('symbols');
        var OPSymbols = shared('op-symbols');
        var ObjectProto = Object[PROTOTYPE];
        var USE_NATIVE = typeof $Symbol == 'function';
        var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
        var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
        var setSymbolDesc = DESCRIPTORS && $fails(function () {
          return _create(dP({}, 'a', {
            get: function () { return dP(this, 'a', { value: 7 }).a; }
          })).a != 7;
        }) ? function (it, key, D) {
          var protoDesc = gOPD(ObjectProto, key);
          if (protoDesc) delete ObjectProto[key];
          dP(it, key, D);
          if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
        } : dP;

        var wrap = function (tag) {
          var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
          sym._k = tag;
          return sym;
        };

        var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
          return typeof it == 'symbol';
        } : function (it) {
          return it instanceof $Symbol;
        };

        var $defineProperty = function defineProperty(it, key, D) {
          if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
          anObject(it);
          key = toPrimitive(key, true);
          anObject(D);
          if (has(AllSymbols, key)) {
            if (!D.enumerable) {
              if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
              it[HIDDEN][key] = true;
            } else {
              if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
              D = _create(D, { enumerable: createDesc(0, false) });
            } return setSymbolDesc(it, key, D);
          } return dP(it, key, D);
        };
        var $defineProperties = function defineProperties(it, P) {
          anObject(it);
          var keys = enumKeys(P = toIObject(P));
          var i = 0;
          var l = keys.length;
          var key;
          while (l > i) $defineProperty(it, key = keys[i++], P[key]);
          return it;
        };
        var $create = function create(it, P) {
          return P === undefined ? _create(it) : $defineProperties(_create(it), P);
        };
        var $propertyIsEnumerable = function propertyIsEnumerable(key) {
          var E = isEnum.call(this, key = toPrimitive(key, true));
          if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
          return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
        };
        var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
          it = toIObject(it);
          key = toPrimitive(key, true);
          if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
          var D = gOPD(it, key);
          if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
          return D;
        };
        var $getOwnPropertyNames = function getOwnPropertyNames(it) {
          var names = gOPN(toIObject(it));
          var result = [];
          var i = 0;
          var key;
          while (names.length > i) {
            if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
          } return result;
        };
        var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
          var IS_OP = it === ObjectProto;
          var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
          var result = [];
          var i = 0;
          var key;
          while (names.length > i) {
            if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
          } return result;
        };

// 19.4.1.1 Symbol([description])
        if (!USE_NATIVE) {
          $Symbol = function Symbol() {
            if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
            var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
            var $set = function (value) {
              if (this === ObjectProto) $set.call(OPSymbols, value);
              if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
              setSymbolDesc(this, tag, createDesc(1, value));
            };
            if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
            return wrap(tag);
          };
          redefine($Symbol[PROTOTYPE], 'toString', function toString() {
            return this._k;
          });

          $GOPD.f = $getOwnPropertyDescriptor;
          $DP.f = $defineProperty;
          require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
          require('./_object-pie').f = $propertyIsEnumerable;
          require('./_object-gops').f = $getOwnPropertySymbols;

          if (DESCRIPTORS && !require('./_library')) {
            redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
          }

          wksExt.f = function (name) {
            return wrap(wks(name));
          };
        }

        $export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

        for (var es6Symbols = (
          // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
          'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
        ).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

        for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

        $export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
          // 19.4.2.1 Symbol.for(key)
          'for': function (key) {
            return has(SymbolRegistry, key += '')
              ? SymbolRegistry[key]
              : SymbolRegistry[key] = $Symbol(key);
          },
          // 19.4.2.5 Symbol.keyFor(sym)
          keyFor: function keyFor(sym) {
            if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
            for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
          },
          useSetter: function () { setter = true; },
          useSimple: function () { setter = false; }
        });

        $export($export.S + $export.F * !USE_NATIVE, 'Object', {
          // 19.1.2.2 Object.create(O [, Properties])
          create: $create,
          // 19.1.2.4 Object.defineProperty(O, P, Attributes)
          defineProperty: $defineProperty,
          // 19.1.2.3 Object.defineProperties(O, Properties)
          defineProperties: $defineProperties,
          // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
          getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
          // 19.1.2.7 Object.getOwnPropertyNames(O)
          getOwnPropertyNames: $getOwnPropertyNames,
          // 19.1.2.8 Object.getOwnPropertySymbols(O)
          getOwnPropertySymbols: $getOwnPropertySymbols
        });

// 24.3.2 JSON.stringify(value [, replacer [, space]])
        $JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
          var S = $Symbol();
          // MS Edge converts symbol values to JSON as {}
          // WebKit converts symbol values to JSON as null
          // V8 throws on boxed symbols
          return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
        })), 'JSON', {
          stringify: function stringify(it) {
            var args = [it];
            var i = 1;
            var replacer, $replacer;
            while (arguments.length > i) args.push(arguments[i++]);
            $replacer = replacer = args[1];
            if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
            if (!isArray(replacer)) replacer = function (key, value) {
              if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
              if (!isSymbol(value)) return value;
            };
            args[1] = replacer;
            return _stringify.apply($JSON, args);
          }
        });

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
        $Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
        setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
        setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
        setToStringTag(global.JSON, 'JSON', true);

      },{"./_an-object":36,"./_descriptors":44,"./_enum-keys":47,"./_export":48,"./_fails":49,"./_global":51,"./_has":52,"./_hide":53,"./_is-array":59,"./_is-object":60,"./_library":67,"./_meta":68,"./_object-create":71,"./_object-dp":72,"./_object-gopd":74,"./_object-gopn":76,"./_object-gopn-ext":75,"./_object-gops":77,"./_object-keys":80,"./_object-pie":81,"./_property-desc":85,"./_redefine":87,"./_set-to-string-tag":90,"./_shared":92,"./_to-iobject":98,"./_to-primitive":101,"./_uid":102,"./_wks":105,"./_wks-define":103,"./_wks-ext":104}],117:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
        'use strict';
        var $export = require('./_export');
        var core = require('./_core');
        var global = require('./_global');
        var speciesConstructor = require('./_species-constructor');
        var promiseResolve = require('./_promise-resolve');

        $export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
          var C = speciesConstructor(this, core.Promise || global.Promise);
          var isFunction = typeof onFinally == 'function';
          return this.then(
            isFunction ? function (x) {
              return promiseResolve(C, onFinally()).then(function () { return x; });
            } : onFinally,
            isFunction ? function (e) {
              return promiseResolve(C, onFinally()).then(function () { throw e; });
            } : onFinally
          );
        } });

      },{"./_core":40,"./_export":48,"./_global":51,"./_promise-resolve":84,"./_species-constructor":93}],118:[function(require,module,exports){
        'use strict';
// https://github.com/tc39/proposal-promise-try
        var $export = require('./_export');
        var newPromiseCapability = require('./_new-promise-capability');
        var perform = require('./_perform');

        $export($export.S, 'Promise', { 'try': function (callbackfn) {
          var promiseCapability = newPromiseCapability.f(this);
          var result = perform(callbackfn);
          (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
          return promiseCapability.promise;
        } });

      },{"./_export":48,"./_new-promise-capability":70,"./_perform":83}],119:[function(require,module,exports){
        require('./_wks-define')('asyncIterator');

      },{"./_wks-define":103}],120:[function(require,module,exports){
        require('./_wks-define')('observable');

      },{"./_wks-define":103}],121:[function(require,module,exports){
        require('./es6.array.iterator');
        var global = require('./_global');
        var hide = require('./_hide');
        var Iterators = require('./_iterators');
        var TO_STRING_TAG = require('./_wks')('toStringTag');

        var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
          'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
          'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
          'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
          'TextTrackList,TouchList').split(',');

        for (var i = 0; i < DOMIterables.length; i++) {
          var NAME = DOMIterables[i];
          var Collection = global[NAME];
          var proto = Collection && Collection.prototype;
          if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
          Iterators[NAME] = Iterators.Array;
        }

      },{"./_global":51,"./_hide":53,"./_iterators":66,"./_wks":105,"./es6.array.iterator":108}],122:[function(require,module,exports){
        'use strict';

        var _buffer = require('buffer');

        var _create_buffer = require('./create_buffer');

        var _create_buffer2 = _interopRequireDefault(_create_buffer);

        var _define_crc = require('./define_crc');

        var _define_crc2 = _interopRequireDefault(_define_crc);

        function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

        module.exports = (0, _define_crc2.default)('xmodem', function (buf, previous) {
          if (!_buffer.Buffer.isBuffer(buf)) buf = (0, _create_buffer2.default)(buf);

          var crc = typeof previous !== 'undefined' ? ~~previous : 0x0;

          for (var index = 0; index < buf.length; index++) {
            var byte = buf[index];
            var code = crc >>> 8 & 0xFF;

            code ^= byte & 0xFF;
            code ^= code >>> 4;
            crc = crc << 8 & 0xFFFF;
            crc ^= code;
            code = code << 5 & 0xFFFF;
            crc ^= code;
            code = code << 7 & 0xFFFF;
            crc ^= code;
          }

          return crc;
        });
      },{"./create_buffer":123,"./define_crc":124,"buffer":24}],123:[function(require,module,exports){
        'use strict';

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        var _buffer = require('buffer');

        var createBuffer = _buffer.Buffer.from && _buffer.Buffer.alloc && _buffer.Buffer.allocUnsafe && _buffer.Buffer.allocUnsafeSlow ? _buffer.Buffer.from

          // support for Node < 5.10
          : function (val) {
            return new _buffer.Buffer(val);
          };

        exports.default = createBuffer;
      },{"buffer":24}],124:[function(require,module,exports){
        "use strict";

        Object.defineProperty(exports, "__esModule", {
          value: true
        });

        exports.default = function (model, calc) {
          var fn = function fn(buf, previous) {
            return calc(buf, previous) >>> 0;
          };
          fn.signed = calc;
          fn.unsigned = fn;
          fn.model = model;

          return fn;
        };
      },{}],125:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

        function EventEmitter() {
          this._events = this._events || {};
          this._maxListeners = this._maxListeners || undefined;
        }
        module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
        EventEmitter.EventEmitter = EventEmitter;

        EventEmitter.prototype._events = undefined;
        EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
        EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
        EventEmitter.prototype.setMaxListeners = function(n) {
          if (!isNumber(n) || n < 0 || isNaN(n))
            throw TypeError('n must be a positive number');
          this._maxListeners = n;
          return this;
        };

        EventEmitter.prototype.emit = function(type) {
          var er, handler, len, args, i, listeners;

          if (!this._events)
            this._events = {};

          // If there is no 'error' event listener then throw.
          if (type === 'error') {
            if (!this._events.error ||
              (isObject(this._events.error) && !this._events.error.length)) {
              er = arguments[1];
              if (er instanceof Error) {
                throw er; // Unhandled 'error' event
              } else {
                // At least give some kind of context to the user
                var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
                err.context = er;
                throw err;
              }
            }
          }

          handler = this._events[type];

          if (isUndefined(handler))
            return false;

          if (isFunction(handler)) {
            switch (arguments.length) {
              // fast cases
              case 1:
                handler.call(this);
                break;
              case 2:
                handler.call(this, arguments[1]);
                break;
              case 3:
                handler.call(this, arguments[1], arguments[2]);
                break;
              // slower
              default:
                args = Array.prototype.slice.call(arguments, 1);
                handler.apply(this, args);
            }
          } else if (isObject(handler)) {
            args = Array.prototype.slice.call(arguments, 1);
            listeners = handler.slice();
            len = listeners.length;
            for (i = 0; i < len; i++)
              listeners[i].apply(this, args);
          }

          return true;
        };

        EventEmitter.prototype.addListener = function(type, listener) {
          var m;

          if (!isFunction(listener))
            throw TypeError('listener must be a function');

          if (!this._events)
            this._events = {};

          // To avoid recursion in the case that type === "newListener"! Before
          // adding it to the listeners, first emit "newListener".
          if (this._events.newListener)
            this.emit('newListener', type,
              isFunction(listener.listener) ?
                listener.listener : listener);

          if (!this._events[type])
          // Optimize the case of one listener. Don't need the extra array object.
            this._events[type] = listener;
          else if (isObject(this._events[type]))
          // If we've already got an array, just append.
            this._events[type].push(listener);
          else
          // Adding the second element, need to change to array.
            this._events[type] = [this._events[type], listener];

          // Check for listener leak
          if (isObject(this._events[type]) && !this._events[type].warned) {
            if (!isUndefined(this._maxListeners)) {
              m = this._maxListeners;
            } else {
              m = EventEmitter.defaultMaxListeners;
            }

            if (m && m > 0 && this._events[type].length > m) {
              this._events[type].warned = true;
              console.error('(node) warning: possible EventEmitter memory ' +
                'leak detected. %d listeners added. ' +
                'Use emitter.setMaxListeners() to increase limit.',
                this._events[type].length);
              if (typeof console.trace === 'function') {
                // not supported in IE 10
                console.trace();
              }
            }
          }

          return this;
        };

        EventEmitter.prototype.on = EventEmitter.prototype.addListener;

        EventEmitter.prototype.once = function(type, listener) {
          if (!isFunction(listener))
            throw TypeError('listener must be a function');

          var fired = false;

          function g() {
            this.removeListener(type, g);

            if (!fired) {
              fired = true;
              listener.apply(this, arguments);
            }
          }

          g.listener = listener;
          this.on(type, g);

          return this;
        };

// emits a 'removeListener' event iff the listener was removed
        EventEmitter.prototype.removeListener = function(type, listener) {
          var list, position, length, i;

          if (!isFunction(listener))
            throw TypeError('listener must be a function');

          if (!this._events || !this._events[type])
            return this;

          list = this._events[type];
          length = list.length;
          position = -1;

          if (list === listener ||
            (isFunction(list.listener) && list.listener === listener)) {
            delete this._events[type];
            if (this._events.removeListener)
              this.emit('removeListener', type, listener);

          } else if (isObject(list)) {
            for (i = length; i-- > 0;) {
              if (list[i] === listener ||
                (list[i].listener && list[i].listener === listener)) {
                position = i;
                break;
              }
            }

            if (position < 0)
              return this;

            if (list.length === 1) {
              list.length = 0;
              delete this._events[type];
            } else {
              list.splice(position, 1);
            }

            if (this._events.removeListener)
              this.emit('removeListener', type, listener);
          }

          return this;
        };

        EventEmitter.prototype.removeAllListeners = function(type) {
          var key, listeners;

          if (!this._events)
            return this;

          // not listening for removeListener, no need to emit
          if (!this._events.removeListener) {
            if (arguments.length === 0)
              this._events = {};
            else if (this._events[type])
              delete this._events[type];
            return this;
          }

          // emit removeListener for all listeners on all events
          if (arguments.length === 0) {
            for (key in this._events) {
              if (key === 'removeListener') continue;
              this.removeAllListeners(key);
            }
            this.removeAllListeners('removeListener');
            this._events = {};
            return this;
          }

          listeners = this._events[type];

          if (isFunction(listeners)) {
            this.removeListener(type, listeners);
          } else if (listeners) {
            // LIFO order
            while (listeners.length)
              this.removeListener(type, listeners[listeners.length - 1]);
          }
          delete this._events[type];

          return this;
        };

        EventEmitter.prototype.listeners = function(type) {
          var ret;
          if (!this._events || !this._events[type])
            ret = [];
          else if (isFunction(this._events[type]))
            ret = [this._events[type]];
          else
            ret = this._events[type].slice();
          return ret;
        };

        EventEmitter.prototype.listenerCount = function(type) {
          if (this._events) {
            var evlistener = this._events[type];

            if (isFunction(evlistener))
              return 1;
            else if (evlistener)
              return evlistener.length;
          }
          return 0;
        };

        EventEmitter.listenerCount = function(emitter, type) {
          return emitter.listenerCount(type);
        };

        function isFunction(arg) {
          return typeof arg === 'function';
        }

        function isNumber(arg) {
          return typeof arg === 'number';
        }

        function isObject(arg) {
          return typeof arg === 'object' && arg !== null;
        }

        function isUndefined(arg) {
          return arg === void 0;
        }

      },{}],126:[function(require,module,exports){
        exports.read = function (buffer, offset, isLE, mLen, nBytes) {
          var e, m
          var eLen = nBytes * 8 - mLen - 1
          var eMax = (1 << eLen) - 1
          var eBias = eMax >> 1
          var nBits = -7
          var i = isLE ? (nBytes - 1) : 0
          var d = isLE ? -1 : 1
          var s = buffer[offset + i]

          i += d

          e = s & ((1 << (-nBits)) - 1)
          s >>= (-nBits)
          nBits += eLen
          for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

          m = e & ((1 << (-nBits)) - 1)
          e >>= (-nBits)
          nBits += mLen
          for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

          if (e === 0) {
            e = 1 - eBias
          } else if (e === eMax) {
            return m ? NaN : ((s ? -1 : 1) * Infinity)
          } else {
            m = m + Math.pow(2, mLen)
            e = e - eBias
          }
          return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
        }

        exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
          var e, m, c
          var eLen = nBytes * 8 - mLen - 1
          var eMax = (1 << eLen) - 1
          var eBias = eMax >> 1
          var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
          var i = isLE ? 0 : (nBytes - 1)
          var d = isLE ? 1 : -1
          var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

          value = Math.abs(value)

          if (isNaN(value) || value === Infinity) {
            m = isNaN(value) ? 1 : 0
            e = eMax
          } else {
            e = Math.floor(Math.log(value) / Math.LN2)
            if (value * (c = Math.pow(2, -e)) < 1) {
              e--
              c *= 2
            }
            if (e + eBias >= 1) {
              value += rt / c
            } else {
              value += rt * Math.pow(2, 1 - eBias)
            }
            if (value * c >= 2) {
              e++
              c /= 2
            }

            if (e + eBias >= eMax) {
              m = 0
              e = eMax
            } else if (e + eBias >= 1) {
              m = (value * c - 1) * Math.pow(2, mLen)
              e = e + eBias
            } else {
              m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
              e = 0
            }
          }

          for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

          e = (e << mLen) | m
          eLen += mLen
          for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

          buffer[offset + i - d] |= s * 128
        }

      },{}],127:[function(require,module,exports){
        if (typeof Object.create === 'function') {
          // implementation from standard node.js 'util' module
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          };
        } else {
          // old school shim for old browsers
          module.exports = function inherits(ctor, superCtor) {
            ctor.super_ = superCtor
            var TempCtor = function () {}
            TempCtor.prototype = superCtor.prototype
            ctor.prototype = new TempCtor()
            ctor.prototype.constructor = ctor
          }
        }

      },{}],128:[function(require,module,exports){
        var toString = {}.toString;

        module.exports = Array.isArray || function (arr) {
          return toString.call(arr) == '[object Array]';
        };

      },{}],129:[function(require,module,exports){
        /**
         * Copyright (c) 2014-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
        var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
        var hadRuntime = g.regeneratorRuntime &&
          Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
        var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
        g.regeneratorRuntime = undefined;

        module.exports = require("./runtime");

        if (hadRuntime) {
          // Restore the original runtime.
          g.regeneratorRuntime = oldRuntime;
        } else {
          // Remove the global property added by runtime.js.
          try {
            delete g.regeneratorRuntime;
          } catch(e) {
            g.regeneratorRuntime = undefined;
          }
        }

      },{"./runtime":130}],130:[function(require,module,exports){
        /**
         * Copyright (c) 2014-present, Facebook, Inc.
         *
         * This source code is licensed under the MIT license found in the
         * LICENSE file in the root directory of this source tree.
         */

        !(function(global) {
          "use strict";

          var Op = Object.prototype;
          var hasOwn = Op.hasOwnProperty;
          var undefined; // More compressible than void 0.
          var $Symbol = typeof Symbol === "function" ? Symbol : {};
          var iteratorSymbol = $Symbol.iterator || "@@iterator";
          var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
          var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

          var inModule = typeof module === "object";
          var runtime = global.regeneratorRuntime;
          if (runtime) {
            if (inModule) {
              // If regeneratorRuntime is defined globally and we're in a module,
              // make the exports object identical to regeneratorRuntime.
              module.exports = runtime;
            }
            // Don't bother evaluating the rest of this file if the runtime was
            // already defined globally.
            return;
          }

          // Define the runtime globally (as expected by generated code) as either
          // module.exports (if we're in a module) or a new, empty object.
          runtime = global.regeneratorRuntime = inModule ? module.exports : {};

          function wrap(innerFn, outerFn, self, tryLocsList) {
            // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
            var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
            var generator = Object.create(protoGenerator.prototype);
            var context = new Context(tryLocsList || []);

            // The ._invoke method unifies the implementations of the .next,
            // .throw, and .return methods.
            generator._invoke = makeInvokeMethod(innerFn, self, context);

            return generator;
          }
          runtime.wrap = wrap;

          // Try/catch helper to minimize deoptimizations. Returns a completion
          // record like context.tryEntries[i].completion. This interface could
          // have been (and was previously) designed to take a closure to be
          // invoked without arguments, but in all the cases we care about we
          // already have an existing method we want to call, so there's no need
          // to create a new function object. We can even get away with assuming
          // the method takes exactly one argument, since that happens to be true
          // in every case, so we don't have to touch the arguments object. The
          // only additional allocation required is the completion record, which
          // has a stable shape and so hopefully should be cheap to allocate.
          function tryCatch(fn, obj, arg) {
            try {
              return { type: "normal", arg: fn.call(obj, arg) };
            } catch (err) {
              return { type: "throw", arg: err };
            }
          }

          var GenStateSuspendedStart = "suspendedStart";
          var GenStateSuspendedYield = "suspendedYield";
          var GenStateExecuting = "executing";
          var GenStateCompleted = "completed";

          // Returning this object from the innerFn has the same effect as
          // breaking out of the dispatch switch statement.
          var ContinueSentinel = {};

          // Dummy constructor functions that we use as the .constructor and
          // .constructor.prototype properties for functions that return Generator
          // objects. For full spec compliance, you may wish to configure your
          // minifier not to mangle the names of these two functions.
          function Generator() {}
          function GeneratorFunction() {}
          function GeneratorFunctionPrototype() {}

          // This is a polyfill for %IteratorPrototype% for environments that
          // don't natively support it.
          var IteratorPrototype = {};
          IteratorPrototype[iteratorSymbol] = function () {
            return this;
          };

          var getProto = Object.getPrototypeOf;
          var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
          if (NativeIteratorPrototype &&
            NativeIteratorPrototype !== Op &&
            hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
            // This environment has a native %IteratorPrototype%; use it instead
            // of the polyfill.
            IteratorPrototype = NativeIteratorPrototype;
          }

          var Gp = GeneratorFunctionPrototype.prototype =
            Generator.prototype = Object.create(IteratorPrototype);
          GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
          GeneratorFunctionPrototype.constructor = GeneratorFunction;
          GeneratorFunctionPrototype[toStringTagSymbol] =
            GeneratorFunction.displayName = "GeneratorFunction";

          // Helper for defining the .next, .throw, and .return methods of the
          // Iterator interface in terms of a single ._invoke method.
          function defineIteratorMethods(prototype) {
            ["next", "throw", "return"].forEach(function(method) {
              prototype[method] = function(arg) {
                return this._invoke(method, arg);
              };
            });
          }

          runtime.isGeneratorFunction = function(genFun) {
            var ctor = typeof genFun === "function" && genFun.constructor;
            return ctor
              ? ctor === GeneratorFunction ||
              // For the native GeneratorFunction constructor, the best we can
              // do is to check its .name property.
              (ctor.displayName || ctor.name) === "GeneratorFunction"
              : false;
          };

          runtime.mark = function(genFun) {
            if (Object.setPrototypeOf) {
              Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
            } else {
              genFun.__proto__ = GeneratorFunctionPrototype;
              if (!(toStringTagSymbol in genFun)) {
                genFun[toStringTagSymbol] = "GeneratorFunction";
              }
            }
            genFun.prototype = Object.create(Gp);
            return genFun;
          };

          // Within the body of any async function, `await x` is transformed to
          // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
          // `hasOwn.call(value, "__await")` to determine if the yielded value is
          // meant to be awaited.
          runtime.awrap = function(arg) {
            return { __await: arg };
          };

          function AsyncIterator(generator) {
            function invoke(method, arg, resolve, reject) {
              var record = tryCatch(generator[method], generator, arg);
              if (record.type === "throw") {
                reject(record.arg);
              } else {
                var result = record.arg;
                var value = result.value;
                if (value &&
                  typeof value === "object" &&
                  hasOwn.call(value, "__await")) {
                  return Promise.resolve(value.__await).then(function(value) {
                    invoke("next", value, resolve, reject);
                  }, function(err) {
                    invoke("throw", err, resolve, reject);
                  });
                }

                return Promise.resolve(value).then(function(unwrapped) {
                  // When a yielded Promise is resolved, its final value becomes
                  // the .value of the Promise<{value,done}> result for the
                  // current iteration. If the Promise is rejected, however, the
                  // result for this iteration will be rejected with the same
                  // reason. Note that rejections of yielded Promises are not
                  // thrown back into the generator function, as is the case
                  // when an awaited Promise is rejected. This difference in
                  // behavior between yield and await is important, because it
                  // allows the consumer to decide what to do with the yielded
                  // rejection (swallow it and continue, manually .throw it back
                  // into the generator, abandon iteration, whatever). With
                  // await, by contrast, there is no opportunity to examine the
                  // rejection reason outside the generator function, so the
                  // only option is to throw it from the await expression, and
                  // let the generator function handle the exception.
                  result.value = unwrapped;
                  resolve(result);
                }, reject);
              }
            }

            var previousPromise;

            function enqueue(method, arg) {
              function callInvokeWithMethodAndArg() {
                return new Promise(function(resolve, reject) {
                  invoke(method, arg, resolve, reject);
                });
              }

              return previousPromise =
                // If enqueue has been called before, then we want to wait until
                // all previous Promises have been resolved before calling invoke,
                // so that results are always delivered in the correct order. If
                // enqueue has not been called before, then it is important to
                // call invoke immediately, without waiting on a callback to fire,
                // so that the async generator function has the opportunity to do
                // any necessary setup in a predictable way. This predictability
                // is why the Promise constructor synchronously invokes its
                // executor callback, and why async functions synchronously
                // execute code before the first await. Since we implement simple
                // async functions in terms of async generators, it is especially
                // important to get this right, even though it requires care.
                previousPromise ? previousPromise.then(
                  callInvokeWithMethodAndArg,
                  // Avoid propagating failures to Promises returned by later
                  // invocations of the iterator.
                  callInvokeWithMethodAndArg
                ) : callInvokeWithMethodAndArg();
            }

            // Define the unified helper method that is used to implement .next,
            // .throw, and .return (see defineIteratorMethods).
            this._invoke = enqueue;
          }

          defineIteratorMethods(AsyncIterator.prototype);
          AsyncIterator.prototype[asyncIteratorSymbol] = function () {
            return this;
          };
          runtime.AsyncIterator = AsyncIterator;

          // Note that simple async functions are implemented on top of
          // AsyncIterator objects; they just return a Promise for the value of
          // the final result produced by the iterator.
          runtime.async = function(innerFn, outerFn, self, tryLocsList) {
            var iter = new AsyncIterator(
              wrap(innerFn, outerFn, self, tryLocsList)
            );

            return runtime.isGeneratorFunction(outerFn)
              ? iter // If outerFn is a generator, return the full iterator.
              : iter.next().then(function(result) {
                return result.done ? result.value : iter.next();
              });
          };

          function makeInvokeMethod(innerFn, self, context) {
            var state = GenStateSuspendedStart;

            return function invoke(method, arg) {
              if (state === GenStateExecuting) {
                throw new Error("Generator is already running");
              }

              if (state === GenStateCompleted) {
                if (method === "throw") {
                  throw arg;
                }

                // Be forgiving, per 25.3.3.3.3 of the spec:
                // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
                return doneResult();
              }

              context.method = method;
              context.arg = arg;

              while (true) {
                var delegate = context.delegate;
                if (delegate) {
                  var delegateResult = maybeInvokeDelegate(delegate, context);
                  if (delegateResult) {
                    if (delegateResult === ContinueSentinel) continue;
                    return delegateResult;
                  }
                }

                if (context.method === "next") {
                  // Setting context._sent for legacy support of Babel's
                  // function.sent implementation.
                  context.sent = context._sent = context.arg;

                } else if (context.method === "throw") {
                  if (state === GenStateSuspendedStart) {
                    state = GenStateCompleted;
                    throw context.arg;
                  }

                  context.dispatchException(context.arg);

                } else if (context.method === "return") {
                  context.abrupt("return", context.arg);
                }

                state = GenStateExecuting;

                var record = tryCatch(innerFn, self, context);
                if (record.type === "normal") {
                  // If an exception is thrown from innerFn, we leave state ===
                  // GenStateExecuting and loop back for another invocation.
                  state = context.done
                    ? GenStateCompleted
                    : GenStateSuspendedYield;

                  if (record.arg === ContinueSentinel) {
                    continue;
                  }

                  return {
                    value: record.arg,
                    done: context.done
                  };

                } else if (record.type === "throw") {
                  state = GenStateCompleted;
                  // Dispatch the exception by looping back around to the
                  // context.dispatchException(context.arg) call above.
                  context.method = "throw";
                  context.arg = record.arg;
                }
              }
            };
          }

          // Call delegate.iterator[context.method](context.arg) and handle the
          // result, either by returning a { value, done } result from the
          // delegate iterator, or by modifying context.method and context.arg,
          // setting context.delegate to null, and returning the ContinueSentinel.
          function maybeInvokeDelegate(delegate, context) {
            var method = delegate.iterator[context.method];
            if (method === undefined) {
              // A .throw or .return when the delegate iterator has no .throw
              // method always terminates the yield* loop.
              context.delegate = null;

              if (context.method === "throw") {
                if (delegate.iterator.return) {
                  // If the delegate iterator has a return method, give it a
                  // chance to clean up.
                  context.method = "return";
                  context.arg = undefined;
                  maybeInvokeDelegate(delegate, context);

                  if (context.method === "throw") {
                    // If maybeInvokeDelegate(context) changed context.method from
                    // "return" to "throw", let that override the TypeError below.
                    return ContinueSentinel;
                  }
                }

                context.method = "throw";
                context.arg = new TypeError(
                  "The iterator does not provide a 'throw' method");
              }

              return ContinueSentinel;
            }

            var record = tryCatch(method, delegate.iterator, context.arg);

            if (record.type === "throw") {
              context.method = "throw";
              context.arg = record.arg;
              context.delegate = null;
              return ContinueSentinel;
            }

            var info = record.arg;

            if (! info) {
              context.method = "throw";
              context.arg = new TypeError("iterator result is not an object");
              context.delegate = null;
              return ContinueSentinel;
            }

            if (info.done) {
              // Assign the result of the finished delegate to the temporary
              // variable specified by delegate.resultName (see delegateYield).
              context[delegate.resultName] = info.value;

              // Resume execution at the desired location (see delegateYield).
              context.next = delegate.nextLoc;

              // If context.method was "throw" but the delegate handled the
              // exception, let the outer generator proceed normally. If
              // context.method was "next", forget context.arg since it has been
              // "consumed" by the delegate iterator. If context.method was
              // "return", allow the original .return call to continue in the
              // outer generator.
              if (context.method !== "return") {
                context.method = "next";
                context.arg = undefined;
              }

            } else {
              // Re-yield the result returned by the delegate method.
              return info;
            }

            // The delegate iterator is finished, so forget it and continue with
            // the outer generator.
            context.delegate = null;
            return ContinueSentinel;
          }

          // Define Generator.prototype.{next,throw,return} in terms of the
          // unified ._invoke helper method.
          defineIteratorMethods(Gp);

          Gp[toStringTagSymbol] = "Generator";

          // A Generator should always return itself as the iterator object when the
          // @@iterator function is called on it. Some browsers' implementations of the
          // iterator prototype chain incorrectly implement this, causing the Generator
          // object to not be returned from this call. This ensures that doesn't happen.
          // See https://github.com/facebook/regenerator/issues/274 for more details.
          Gp[iteratorSymbol] = function() {
            return this;
          };

          Gp.toString = function() {
            return "[object Generator]";
          };

          function pushTryEntry(locs) {
            var entry = { tryLoc: locs[0] };

            if (1 in locs) {
              entry.catchLoc = locs[1];
            }

            if (2 in locs) {
              entry.finallyLoc = locs[2];
              entry.afterLoc = locs[3];
            }

            this.tryEntries.push(entry);
          }

          function resetTryEntry(entry) {
            var record = entry.completion || {};
            record.type = "normal";
            delete record.arg;
            entry.completion = record;
          }

          function Context(tryLocsList) {
            // The root entry object (effectively a try statement without a catch
            // or a finally block) gives us a place to store values thrown from
            // locations where there is no enclosing try statement.
            this.tryEntries = [{ tryLoc: "root" }];
            tryLocsList.forEach(pushTryEntry, this);
            this.reset(true);
          }

          runtime.keys = function(object) {
            var keys = [];
            for (var key in object) {
              keys.push(key);
            }
            keys.reverse();

            // Rather than returning an object with a next method, we keep
            // things simple and return the next function itself.
            return function next() {
              while (keys.length) {
                var key = keys.pop();
                if (key in object) {
                  next.value = key;
                  next.done = false;
                  return next;
                }
              }

              // To avoid creating an additional object, we just hang the .value
              // and .done properties off the next function object itself. This
              // also ensures that the minifier will not anonymize the function.
              next.done = true;
              return next;
            };
          };

          function values(iterable) {
            if (iterable) {
              var iteratorMethod = iterable[iteratorSymbol];
              if (iteratorMethod) {
                return iteratorMethod.call(iterable);
              }

              if (typeof iterable.next === "function") {
                return iterable;
              }

              if (!isNaN(iterable.length)) {
                var i = -1, next = function next() {
                  while (++i < iterable.length) {
                    if (hasOwn.call(iterable, i)) {
                      next.value = iterable[i];
                      next.done = false;
                      return next;
                    }
                  }

                  next.value = undefined;
                  next.done = true;

                  return next;
                };

                return next.next = next;
              }
            }

            // Return an iterator with no values.
            return { next: doneResult };
          }
          runtime.values = values;

          function doneResult() {
            return { value: undefined, done: true };
          }

          Context.prototype = {
            constructor: Context,

            reset: function(skipTempReset) {
              this.prev = 0;
              this.next = 0;
              // Resetting context._sent for legacy support of Babel's
              // function.sent implementation.
              this.sent = this._sent = undefined;
              this.done = false;
              this.delegate = null;

              this.method = "next";
              this.arg = undefined;

              this.tryEntries.forEach(resetTryEntry);

              if (!skipTempReset) {
                for (var name in this) {
                  // Not sure about the optimal order of these conditions:
                  if (name.charAt(0) === "t" &&
                    hasOwn.call(this, name) &&
                    !isNaN(+name.slice(1))) {
                    this[name] = undefined;
                  }
                }
              }
            },

            stop: function() {
              this.done = true;

              var rootEntry = this.tryEntries[0];
              var rootRecord = rootEntry.completion;
              if (rootRecord.type === "throw") {
                throw rootRecord.arg;
              }

              return this.rval;
            },

            dispatchException: function(exception) {
              if (this.done) {
                throw exception;
              }

              var context = this;
              function handle(loc, caught) {
                record.type = "throw";
                record.arg = exception;
                context.next = loc;

                if (caught) {
                  // If the dispatched exception was caught by a catch block,
                  // then let that catch block handle the exception normally.
                  context.method = "next";
                  context.arg = undefined;
                }

                return !! caught;
              }

              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                var record = entry.completion;

                if (entry.tryLoc === "root") {
                  // Exception thrown outside of any try block that could handle
                  // it, so set the completion value of the entire function to
                  // throw the exception.
                  return handle("end");
                }

                if (entry.tryLoc <= this.prev) {
                  var hasCatch = hasOwn.call(entry, "catchLoc");
                  var hasFinally = hasOwn.call(entry, "finallyLoc");

                  if (hasCatch && hasFinally) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true);
                    } else if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc);
                    }

                  } else if (hasCatch) {
                    if (this.prev < entry.catchLoc) {
                      return handle(entry.catchLoc, true);
                    }

                  } else if (hasFinally) {
                    if (this.prev < entry.finallyLoc) {
                      return handle(entry.finallyLoc);
                    }

                  } else {
                    throw new Error("try statement without catch or finally");
                  }
                }
              }
            },

            abrupt: function(type, arg) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev &&
                  hasOwn.call(entry, "finallyLoc") &&
                  this.prev < entry.finallyLoc) {
                  var finallyEntry = entry;
                  break;
                }
              }

              if (finallyEntry &&
                (type === "break" ||
                  type === "continue") &&
                finallyEntry.tryLoc <= arg &&
                arg <= finallyEntry.finallyLoc) {
                // Ignore the finally entry if control is not jumping to a
                // location outside the try/catch block.
                finallyEntry = null;
              }

              var record = finallyEntry ? finallyEntry.completion : {};
              record.type = type;
              record.arg = arg;

              if (finallyEntry) {
                this.method = "next";
                this.next = finallyEntry.finallyLoc;
                return ContinueSentinel;
              }

              return this.complete(record);
            },

            complete: function(record, afterLoc) {
              if (record.type === "throw") {
                throw record.arg;
              }

              if (record.type === "break" ||
                record.type === "continue") {
                this.next = record.arg;
              } else if (record.type === "return") {
                this.rval = this.arg = record.arg;
                this.method = "return";
                this.next = "end";
              } else if (record.type === "normal" && afterLoc) {
                this.next = afterLoc;
              }

              return ContinueSentinel;
            },

            finish: function(finallyLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) {
                  this.complete(entry.completion, entry.afterLoc);
                  resetTryEntry(entry);
                  return ContinueSentinel;
                }
              }
            },

            "catch": function(tryLoc) {
              for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                  var record = entry.completion;
                  if (record.type === "throw") {
                    var thrown = record.arg;
                    resetTryEntry(entry);
                  }
                  return thrown;
                }
              }

              // The context.catch method must only be called with a location
              // argument that corresponds to a known catch block.
              throw new Error("illegal catch attempt");
            },

            delegateYield: function(iterable, resultName, nextLoc) {
              this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
              };

              if (this.method === "next") {
                // Deliberately forget the last sent value so that we don't
                // accidentally pass it on to the delegate.
                this.arg = undefined;
              }

              return ContinueSentinel;
            }
          };
        })(
          // In sloppy mode, unbound `this` refers to the global object, fallback to
          // Function constructor if we're in global strict mode. That is sadly a form
          // of indirect eval which violates Content Security Policy.
          (function() { return this })() || Function("return this")()
        );

      },{}],131:[function(require,module,exports){
        /* eslint-disable node/no-deprecated-api */
        var buffer = require('buffer')
        var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
        function copyProps (src, dst) {
          for (var key in src) {
            dst[key] = src[key]
          }
        }
        if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
          module.exports = buffer
        } else {
          // Copy properties from require('buffer')
          copyProps(buffer, exports)
          exports.Buffer = SafeBuffer
        }

        function SafeBuffer (arg, encodingOrOffset, length) {
          return Buffer(arg, encodingOrOffset, length)
        }

// Copy static methods from Buffer
        copyProps(Buffer, SafeBuffer)

        SafeBuffer.from = function (arg, encodingOrOffset, length) {
          if (typeof arg === 'number') {
            throw new TypeError('Argument must not be a number')
          }
          return Buffer(arg, encodingOrOffset, length)
        }

        SafeBuffer.alloc = function (size, fill, encoding) {
          if (typeof size !== 'number') {
            throw new TypeError('Argument must be a number')
          }
          var buf = Buffer(size)
          if (fill !== undefined) {
            if (typeof encoding === 'string') {
              buf.fill(fill, encoding)
            } else {
              buf.fill(fill)
            }
          } else {
            buf.fill(0)
          }
          return buf
        }

        SafeBuffer.allocUnsafe = function (size) {
          if (typeof size !== 'number') {
            throw new TypeError('Argument must be a number')
          }
          return Buffer(size)
        }

        SafeBuffer.allocUnsafeSlow = function (size) {
          if (typeof size !== 'number') {
            throw new TypeError('Argument must be a number')
          }
          return buffer.SlowBuffer(size)
        }

      },{"buffer":24}],132:[function(require,module,exports){
        var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
        function Hash (blockSize, finalSize) {
          this._block = Buffer.alloc(blockSize)
          this._finalSize = finalSize
          this._blockSize = blockSize
          this._len = 0
        }

        Hash.prototype.update = function (data, enc) {
          if (typeof data === 'string') {
            enc = enc || 'utf8'
            data = Buffer.from(data, enc)
          }

          var block = this._block
          var blockSize = this._blockSize
          var length = data.length
          var accum = this._len

          for (var offset = 0; offset < length;) {
            var assigned = accum % blockSize
            var remainder = Math.min(length - offset, blockSize - assigned)

            for (var i = 0; i < remainder; i++) {
              block[assigned + i] = data[offset + i]
            }

            accum += remainder
            offset += remainder

            if ((accum % blockSize) === 0) {
              this._update(block)
            }
          }

          this._len += length
          return this
        }

        Hash.prototype.digest = function (enc) {
          var rem = this._len % this._blockSize

          this._block[rem] = 0x80

          // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
          // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
          this._block.fill(0, rem + 1)

          if (rem >= this._finalSize) {
            this._update(this._block)
            this._block.fill(0)
          }

          var bits = this._len * 8

          // uint32
          if (bits <= 0xffffffff) {
            this._block.writeUInt32BE(bits, this._blockSize - 4)

            // uint64
          } else {
            var lowBits = (bits & 0xffffffff) >>> 0
            var highBits = (bits - lowBits) / 0x100000000

            this._block.writeUInt32BE(highBits, this._blockSize - 8)
            this._block.writeUInt32BE(lowBits, this._blockSize - 4)
          }

          this._update(this._block)
          var hash = this._hash()

          return enc ? hash.toString(enc) : hash
        }

        Hash.prototype._update = function () {
          throw new Error('_update must be implemented by subclass')
        }

        module.exports = Hash

      },{"safe-buffer":131}],133:[function(require,module,exports){
        var exports = module.exports = function SHA (algorithm) {
          algorithm = algorithm.toLowerCase()

          var Algorithm = exports[algorithm]
          if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

          return new Algorithm()
        }

        exports.sha = require('./sha')
        exports.sha1 = require('./sha1')
        exports.sha224 = require('./sha224')
        exports.sha256 = require('./sha256')
        exports.sha384 = require('./sha384')
        exports.sha512 = require('./sha512')

      },{"./sha":134,"./sha1":135,"./sha224":136,"./sha256":137,"./sha384":138,"./sha512":139}],134:[function(require,module,exports){
        /*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

        var inherits = require('inherits')
        var Hash = require('./hash')
        var Buffer = require('safe-buffer').Buffer

        var K = [
          0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
        ]

        var W = new Array(80)

        function Sha () {
          this.init()
          this._w = W

          Hash.call(this, 64, 56)
        }

        inherits(Sha, Hash)

        Sha.prototype.init = function () {
          this._a = 0x67452301
          this._b = 0xefcdab89
          this._c = 0x98badcfe
          this._d = 0x10325476
          this._e = 0xc3d2e1f0

          return this
        }

        function rotl5 (num) {
          return (num << 5) | (num >>> 27)
        }

        function rotl30 (num) {
          return (num << 30) | (num >>> 2)
        }

        function ft (s, b, c, d) {
          if (s === 0) return (b & c) | ((~b) & d)
          if (s === 2) return (b & c) | (b & d) | (c & d)
          return b ^ c ^ d
        }

        Sha.prototype._update = function (M) {
          var W = this._w

          var a = this._a | 0
          var b = this._b | 0
          var c = this._c | 0
          var d = this._d | 0
          var e = this._e | 0

          for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
          for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

          for (var j = 0; j < 80; ++j) {
            var s = ~~(j / 20)
            var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

            e = d
            d = c
            c = rotl30(b)
            b = a
            a = t
          }

          this._a = (a + this._a) | 0
          this._b = (b + this._b) | 0
          this._c = (c + this._c) | 0
          this._d = (d + this._d) | 0
          this._e = (e + this._e) | 0
        }

        Sha.prototype._hash = function () {
          var H = Buffer.allocUnsafe(20)

          H.writeInt32BE(this._a | 0, 0)
          H.writeInt32BE(this._b | 0, 4)
          H.writeInt32BE(this._c | 0, 8)
          H.writeInt32BE(this._d | 0, 12)
          H.writeInt32BE(this._e | 0, 16)

          return H
        }

        module.exports = Sha

      },{"./hash":132,"inherits":127,"safe-buffer":131}],135:[function(require,module,exports){
        /*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

        var inherits = require('inherits')
        var Hash = require('./hash')
        var Buffer = require('safe-buffer').Buffer

        var K = [
          0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
        ]

        var W = new Array(80)

        function Sha1 () {
          this.init()
          this._w = W

          Hash.call(this, 64, 56)
        }

        inherits(Sha1, Hash)

        Sha1.prototype.init = function () {
          this._a = 0x67452301
          this._b = 0xefcdab89
          this._c = 0x98badcfe
          this._d = 0x10325476
          this._e = 0xc3d2e1f0

          return this
        }

        function rotl1 (num) {
          return (num << 1) | (num >>> 31)
        }

        function rotl5 (num) {
          return (num << 5) | (num >>> 27)
        }

        function rotl30 (num) {
          return (num << 30) | (num >>> 2)
        }

        function ft (s, b, c, d) {
          if (s === 0) return (b & c) | ((~b) & d)
          if (s === 2) return (b & c) | (b & d) | (c & d)
          return b ^ c ^ d
        }

        Sha1.prototype._update = function (M) {
          var W = this._w

          var a = this._a | 0
          var b = this._b | 0
          var c = this._c | 0
          var d = this._d | 0
          var e = this._e | 0

          for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
          for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

          for (var j = 0; j < 80; ++j) {
            var s = ~~(j / 20)
            var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

            e = d
            d = c
            c = rotl30(b)
            b = a
            a = t
          }

          this._a = (a + this._a) | 0
          this._b = (b + this._b) | 0
          this._c = (c + this._c) | 0
          this._d = (d + this._d) | 0
          this._e = (e + this._e) | 0
        }

        Sha1.prototype._hash = function () {
          var H = Buffer.allocUnsafe(20)

          H.writeInt32BE(this._a | 0, 0)
          H.writeInt32BE(this._b | 0, 4)
          H.writeInt32BE(this._c | 0, 8)
          H.writeInt32BE(this._d | 0, 12)
          H.writeInt32BE(this._e | 0, 16)

          return H
        }

        module.exports = Sha1

      },{"./hash":132,"inherits":127,"safe-buffer":131}],136:[function(require,module,exports){
        /**
         * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
         * in FIPS 180-2
         * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
         *
         */

        var inherits = require('inherits')
        var Sha256 = require('./sha256')
        var Hash = require('./hash')
        var Buffer = require('safe-buffer').Buffer

        var W = new Array(64)

        function Sha224 () {
          this.init()

          this._w = W // new Array(64)

          Hash.call(this, 64, 56)
        }

        inherits(Sha224, Sha256)

        Sha224.prototype.init = function () {
          this._a = 0xc1059ed8
          this._b = 0x367cd507
          this._c = 0x3070dd17
          this._d = 0xf70e5939
          this._e = 0xffc00b31
          this._f = 0x68581511
          this._g = 0x64f98fa7
          this._h = 0xbefa4fa4

          return this
        }

        Sha224.prototype._hash = function () {
          var H = Buffer.allocUnsafe(28)

          H.writeInt32BE(this._a, 0)
          H.writeInt32BE(this._b, 4)
          H.writeInt32BE(this._c, 8)
          H.writeInt32BE(this._d, 12)
          H.writeInt32BE(this._e, 16)
          H.writeInt32BE(this._f, 20)
          H.writeInt32BE(this._g, 24)

          return H
        }

        module.exports = Sha224

      },{"./hash":132,"./sha256":137,"inherits":127,"safe-buffer":131}],137:[function(require,module,exports){
        /**
         * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
         * in FIPS 180-2
         * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
         * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
         *
         */

        var inherits = require('inherits')
        var Hash = require('./hash')
        var Buffer = require('safe-buffer').Buffer

        var K = [
          0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
          0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
          0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
          0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
          0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
          0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
          0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
          0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
          0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
          0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
          0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
          0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
          0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
          0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
          0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
          0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
        ]

        var W = new Array(64)

        function Sha256 () {
          this.init()

          this._w = W // new Array(64)

          Hash.call(this, 64, 56)
        }

        inherits(Sha256, Hash)

        Sha256.prototype.init = function () {
          this._a = 0x6a09e667
          this._b = 0xbb67ae85
          this._c = 0x3c6ef372
          this._d = 0xa54ff53a
          this._e = 0x510e527f
          this._f = 0x9b05688c
          this._g = 0x1f83d9ab
          this._h = 0x5be0cd19

          return this
        }

        function ch (x, y, z) {
          return z ^ (x & (y ^ z))
        }

        function maj (x, y, z) {
          return (x & y) | (z & (x | y))
        }

        function sigma0 (x) {
          return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
        }

        function sigma1 (x) {
          return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
        }

        function gamma0 (x) {
          return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
        }

        function gamma1 (x) {
          return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
        }

        Sha256.prototype._update = function (M) {
          var W = this._w

          var a = this._a | 0
          var b = this._b | 0
          var c = this._c | 0
          var d = this._d | 0
          var e = this._e | 0
          var f = this._f | 0
          var g = this._g | 0
          var h = this._h | 0

          for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
          for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

          for (var j = 0; j < 64; ++j) {
            var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
            var T2 = (sigma0(a) + maj(a, b, c)) | 0

            h = g
            g = f
            f = e
            e = (d + T1) | 0
            d = c
            c = b
            b = a
            a = (T1 + T2) | 0
          }

          this._a = (a + this._a) | 0
          this._b = (b + this._b) | 0
          this._c = (c + this._c) | 0
          this._d = (d + this._d) | 0
          this._e = (e + this._e) | 0
          this._f = (f + this._f) | 0
          this._g = (g + this._g) | 0
          this._h = (h + this._h) | 0
        }

        Sha256.prototype._hash = function () {
          var H = Buffer.allocUnsafe(32)

          H.writeInt32BE(this._a, 0)
          H.writeInt32BE(this._b, 4)
          H.writeInt32BE(this._c, 8)
          H.writeInt32BE(this._d, 12)
          H.writeInt32BE(this._e, 16)
          H.writeInt32BE(this._f, 20)
          H.writeInt32BE(this._g, 24)
          H.writeInt32BE(this._h, 28)

          return H
        }

        module.exports = Sha256

      },{"./hash":132,"inherits":127,"safe-buffer":131}],138:[function(require,module,exports){
        var inherits = require('inherits')
        var SHA512 = require('./sha512')
        var Hash = require('./hash')
        var Buffer = require('safe-buffer').Buffer

        var W = new Array(160)

        function Sha384 () {
          this.init()
          this._w = W

          Hash.call(this, 128, 112)
        }

        inherits(Sha384, SHA512)

        Sha384.prototype.init = function () {
          this._ah = 0xcbbb9d5d
          this._bh = 0x629a292a
          this._ch = 0x9159015a
          this._dh = 0x152fecd8
          this._eh = 0x67332667
          this._fh = 0x8eb44a87
          this._gh = 0xdb0c2e0d
          this._hh = 0x47b5481d

          this._al = 0xc1059ed8
          this._bl = 0x367cd507
          this._cl = 0x3070dd17
          this._dl = 0xf70e5939
          this._el = 0xffc00b31
          this._fl = 0x68581511
          this._gl = 0x64f98fa7
          this._hl = 0xbefa4fa4

          return this
        }

        Sha384.prototype._hash = function () {
          var H = Buffer.allocUnsafe(48)

          function writeInt64BE (h, l, offset) {
            H.writeInt32BE(h, offset)
            H.writeInt32BE(l, offset + 4)
          }

          writeInt64BE(this._ah, this._al, 0)
          writeInt64BE(this._bh, this._bl, 8)
          writeInt64BE(this._ch, this._cl, 16)
          writeInt64BE(this._dh, this._dl, 24)
          writeInt64BE(this._eh, this._el, 32)
          writeInt64BE(this._fh, this._fl, 40)

          return H
        }

        module.exports = Sha384

      },{"./hash":132,"./sha512":139,"inherits":127,"safe-buffer":131}],139:[function(require,module,exports){
        var inherits = require('inherits')
        var Hash = require('./hash')
        var Buffer = require('safe-buffer').Buffer

        var K = [
          0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
          0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
          0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
          0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
          0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
          0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
          0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
          0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
          0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
          0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
          0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
          0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
          0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
          0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
          0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
          0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
          0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
          0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
          0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
          0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
          0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
          0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
          0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
          0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
          0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
          0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
          0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
          0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
          0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
          0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
          0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
          0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
          0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
          0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
          0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
          0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
          0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
          0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
          0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
          0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
        ]

        var W = new Array(160)

        function Sha512 () {
          this.init()
          this._w = W

          Hash.call(this, 128, 112)
        }

        inherits(Sha512, Hash)

        Sha512.prototype.init = function () {
          this._ah = 0x6a09e667
          this._bh = 0xbb67ae85
          this._ch = 0x3c6ef372
          this._dh = 0xa54ff53a
          this._eh = 0x510e527f
          this._fh = 0x9b05688c
          this._gh = 0x1f83d9ab
          this._hh = 0x5be0cd19

          this._al = 0xf3bcc908
          this._bl = 0x84caa73b
          this._cl = 0xfe94f82b
          this._dl = 0x5f1d36f1
          this._el = 0xade682d1
          this._fl = 0x2b3e6c1f
          this._gl = 0xfb41bd6b
          this._hl = 0x137e2179

          return this
        }

        function Ch (x, y, z) {
          return z ^ (x & (y ^ z))
        }

        function maj (x, y, z) {
          return (x & y) | (z & (x | y))
        }

        function sigma0 (x, xl) {
          return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
        }

        function sigma1 (x, xl) {
          return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
        }

        function Gamma0 (x, xl) {
          return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
        }

        function Gamma0l (x, xl) {
          return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
        }

        function Gamma1 (x, xl) {
          return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
        }

        function Gamma1l (x, xl) {
          return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
        }

        function getCarry (a, b) {
          return (a >>> 0) < (b >>> 0) ? 1 : 0
        }

        Sha512.prototype._update = function (M) {
          var W = this._w

          var ah = this._ah | 0
          var bh = this._bh | 0
          var ch = this._ch | 0
          var dh = this._dh | 0
          var eh = this._eh | 0
          var fh = this._fh | 0
          var gh = this._gh | 0
          var hh = this._hh | 0

          var al = this._al | 0
          var bl = this._bl | 0
          var cl = this._cl | 0
          var dl = this._dl | 0
          var el = this._el | 0
          var fl = this._fl | 0
          var gl = this._gl | 0
          var hl = this._hl | 0

          for (var i = 0; i < 32; i += 2) {
            W[i] = M.readInt32BE(i * 4)
            W[i + 1] = M.readInt32BE(i * 4 + 4)
          }
          for (; i < 160; i += 2) {
            var xh = W[i - 15 * 2]
            var xl = W[i - 15 * 2 + 1]
            var gamma0 = Gamma0(xh, xl)
            var gamma0l = Gamma0l(xl, xh)

            xh = W[i - 2 * 2]
            xl = W[i - 2 * 2 + 1]
            var gamma1 = Gamma1(xh, xl)
            var gamma1l = Gamma1l(xl, xh)

            // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
            var Wi7h = W[i - 7 * 2]
            var Wi7l = W[i - 7 * 2 + 1]

            var Wi16h = W[i - 16 * 2]
            var Wi16l = W[i - 16 * 2 + 1]

            var Wil = (gamma0l + Wi7l) | 0
            var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
            Wil = (Wil + gamma1l) | 0
            Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
            Wil = (Wil + Wi16l) | 0
            Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

            W[i] = Wih
            W[i + 1] = Wil
          }

          for (var j = 0; j < 160; j += 2) {
            Wih = W[j]
            Wil = W[j + 1]

            var majh = maj(ah, bh, ch)
            var majl = maj(al, bl, cl)

            var sigma0h = sigma0(ah, al)
            var sigma0l = sigma0(al, ah)
            var sigma1h = sigma1(eh, el)
            var sigma1l = sigma1(el, eh)

            // t1 = h + sigma1 + ch + K[j] + W[j]
            var Kih = K[j]
            var Kil = K[j + 1]

            var chh = Ch(eh, fh, gh)
            var chl = Ch(el, fl, gl)

            var t1l = (hl + sigma1l) | 0
            var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
            t1l = (t1l + chl) | 0
            t1h = (t1h + chh + getCarry(t1l, chl)) | 0
            t1l = (t1l + Kil) | 0
            t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
            t1l = (t1l + Wil) | 0
            t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

            // t2 = sigma0 + maj
            var t2l = (sigma0l + majl) | 0
            var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

            hh = gh
            hl = gl
            gh = fh
            gl = fl
            fh = eh
            fl = el
            el = (dl + t1l) | 0
            eh = (dh + t1h + getCarry(el, dl)) | 0
            dh = ch
            dl = cl
            ch = bh
            cl = bl
            bh = ah
            bl = al
            al = (t1l + t2l) | 0
            ah = (t1h + t2h + getCarry(al, t1l)) | 0
          }

          this._al = (this._al + al) | 0
          this._bl = (this._bl + bl) | 0
          this._cl = (this._cl + cl) | 0
          this._dl = (this._dl + dl) | 0
          this._el = (this._el + el) | 0
          this._fl = (this._fl + fl) | 0
          this._gl = (this._gl + gl) | 0
          this._hl = (this._hl + hl) | 0

          this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
          this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
          this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
          this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
          this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
          this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
          this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
          this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
        }

        Sha512.prototype._hash = function () {
          var H = Buffer.allocUnsafe(64)

          function writeInt64BE (h, l, offset) {
            H.writeInt32BE(h, offset)
            H.writeInt32BE(l, offset + 4)
          }

          writeInt64BE(this._ah, this._al, 0)
          writeInt64BE(this._bh, this._bl, 8)
          writeInt64BE(this._ch, this._cl, 16)
          writeInt64BE(this._dh, this._dl, 24)
          writeInt64BE(this._eh, this._el, 32)
          writeInt64BE(this._fh, this._fl, 40)
          writeInt64BE(this._gh, this._gl, 48)
          writeInt64BE(this._hh, this._hl, 56)

          return H
        }

        module.exports = Sha512

      },{"./hash":132,"inherits":127,"safe-buffer":131}],140:[function(require,module,exports){
        (function(nacl) {
          'use strict';

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

          var gf = function(init) {
            var i, r = new Float64Array(16);
            if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
            return r;
          };

//  Pluggable, initialized in high-level API below.
          var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

          var _0 = new Uint8Array(16);
          var _9 = new Uint8Array(32); _9[0] = 9;

          var gf0 = gf(),
            gf1 = gf([1]),
            _121665 = gf([0xdb41, 1]),
            D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
            D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
            X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
            Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
            I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

          function ts64(x, i, h, l) {
            x[i]   = (h >> 24) & 0xff;
            x[i+1] = (h >> 16) & 0xff;
            x[i+2] = (h >>  8) & 0xff;
            x[i+3] = h & 0xff;
            x[i+4] = (l >> 24)  & 0xff;
            x[i+5] = (l >> 16)  & 0xff;
            x[i+6] = (l >>  8)  & 0xff;
            x[i+7] = l & 0xff;
          }

          function vn(x, xi, y, yi, n) {
            var i,d = 0;
            for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
            return (1 & ((d - 1) >>> 8)) - 1;
          }

          function crypto_verify_16(x, xi, y, yi) {
            return vn(x,xi,y,yi,16);
          }

          function crypto_verify_32(x, xi, y, yi) {
            return vn(x,xi,y,yi,32);
          }

          function core_salsa20(o, p, k, c) {
            var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
              j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
              j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
              j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
              j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
              j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
              j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
              j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
              j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
              j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
              j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
              j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
              j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
              j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
              j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
              j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

            var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
              x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
              x15 = j15, u;

            for (var i = 0; i < 20; i += 2) {
              u = x0 + x12 | 0;
              x4 ^= u<<7 | u>>>(32-7);
              u = x4 + x0 | 0;
              x8 ^= u<<9 | u>>>(32-9);
              u = x8 + x4 | 0;
              x12 ^= u<<13 | u>>>(32-13);
              u = x12 + x8 | 0;
              x0 ^= u<<18 | u>>>(32-18);

              u = x5 + x1 | 0;
              x9 ^= u<<7 | u>>>(32-7);
              u = x9 + x5 | 0;
              x13 ^= u<<9 | u>>>(32-9);
              u = x13 + x9 | 0;
              x1 ^= u<<13 | u>>>(32-13);
              u = x1 + x13 | 0;
              x5 ^= u<<18 | u>>>(32-18);

              u = x10 + x6 | 0;
              x14 ^= u<<7 | u>>>(32-7);
              u = x14 + x10 | 0;
              x2 ^= u<<9 | u>>>(32-9);
              u = x2 + x14 | 0;
              x6 ^= u<<13 | u>>>(32-13);
              u = x6 + x2 | 0;
              x10 ^= u<<18 | u>>>(32-18);

              u = x15 + x11 | 0;
              x3 ^= u<<7 | u>>>(32-7);
              u = x3 + x15 | 0;
              x7 ^= u<<9 | u>>>(32-9);
              u = x7 + x3 | 0;
              x11 ^= u<<13 | u>>>(32-13);
              u = x11 + x7 | 0;
              x15 ^= u<<18 | u>>>(32-18);

              u = x0 + x3 | 0;
              x1 ^= u<<7 | u>>>(32-7);
              u = x1 + x0 | 0;
              x2 ^= u<<9 | u>>>(32-9);
              u = x2 + x1 | 0;
              x3 ^= u<<13 | u>>>(32-13);
              u = x3 + x2 | 0;
              x0 ^= u<<18 | u>>>(32-18);

              u = x5 + x4 | 0;
              x6 ^= u<<7 | u>>>(32-7);
              u = x6 + x5 | 0;
              x7 ^= u<<9 | u>>>(32-9);
              u = x7 + x6 | 0;
              x4 ^= u<<13 | u>>>(32-13);
              u = x4 + x7 | 0;
              x5 ^= u<<18 | u>>>(32-18);

              u = x10 + x9 | 0;
              x11 ^= u<<7 | u>>>(32-7);
              u = x11 + x10 | 0;
              x8 ^= u<<9 | u>>>(32-9);
              u = x8 + x11 | 0;
              x9 ^= u<<13 | u>>>(32-13);
              u = x9 + x8 | 0;
              x10 ^= u<<18 | u>>>(32-18);

              u = x15 + x14 | 0;
              x12 ^= u<<7 | u>>>(32-7);
              u = x12 + x15 | 0;
              x13 ^= u<<9 | u>>>(32-9);
              u = x13 + x12 | 0;
              x14 ^= u<<13 | u>>>(32-13);
              u = x14 + x13 | 0;
              x15 ^= u<<18 | u>>>(32-18);
            }
            x0 =  x0 +  j0 | 0;
            x1 =  x1 +  j1 | 0;
            x2 =  x2 +  j2 | 0;
            x3 =  x3 +  j3 | 0;
            x4 =  x4 +  j4 | 0;
            x5 =  x5 +  j5 | 0;
            x6 =  x6 +  j6 | 0;
            x7 =  x7 +  j7 | 0;
            x8 =  x8 +  j8 | 0;
            x9 =  x9 +  j9 | 0;
            x10 = x10 + j10 | 0;
            x11 = x11 + j11 | 0;
            x12 = x12 + j12 | 0;
            x13 = x13 + j13 | 0;
            x14 = x14 + j14 | 0;
            x15 = x15 + j15 | 0;

            o[ 0] = x0 >>>  0 & 0xff;
            o[ 1] = x0 >>>  8 & 0xff;
            o[ 2] = x0 >>> 16 & 0xff;
            o[ 3] = x0 >>> 24 & 0xff;

            o[ 4] = x1 >>>  0 & 0xff;
            o[ 5] = x1 >>>  8 & 0xff;
            o[ 6] = x1 >>> 16 & 0xff;
            o[ 7] = x1 >>> 24 & 0xff;

            o[ 8] = x2 >>>  0 & 0xff;
            o[ 9] = x2 >>>  8 & 0xff;
            o[10] = x2 >>> 16 & 0xff;
            o[11] = x2 >>> 24 & 0xff;

            o[12] = x3 >>>  0 & 0xff;
            o[13] = x3 >>>  8 & 0xff;
            o[14] = x3 >>> 16 & 0xff;
            o[15] = x3 >>> 24 & 0xff;

            o[16] = x4 >>>  0 & 0xff;
            o[17] = x4 >>>  8 & 0xff;
            o[18] = x4 >>> 16 & 0xff;
            o[19] = x4 >>> 24 & 0xff;

            o[20] = x5 >>>  0 & 0xff;
            o[21] = x5 >>>  8 & 0xff;
            o[22] = x5 >>> 16 & 0xff;
            o[23] = x5 >>> 24 & 0xff;

            o[24] = x6 >>>  0 & 0xff;
            o[25] = x6 >>>  8 & 0xff;
            o[26] = x6 >>> 16 & 0xff;
            o[27] = x6 >>> 24 & 0xff;

            o[28] = x7 >>>  0 & 0xff;
            o[29] = x7 >>>  8 & 0xff;
            o[30] = x7 >>> 16 & 0xff;
            o[31] = x7 >>> 24 & 0xff;

            o[32] = x8 >>>  0 & 0xff;
            o[33] = x8 >>>  8 & 0xff;
            o[34] = x8 >>> 16 & 0xff;
            o[35] = x8 >>> 24 & 0xff;

            o[36] = x9 >>>  0 & 0xff;
            o[37] = x9 >>>  8 & 0xff;
            o[38] = x9 >>> 16 & 0xff;
            o[39] = x9 >>> 24 & 0xff;

            o[40] = x10 >>>  0 & 0xff;
            o[41] = x10 >>>  8 & 0xff;
            o[42] = x10 >>> 16 & 0xff;
            o[43] = x10 >>> 24 & 0xff;

            o[44] = x11 >>>  0 & 0xff;
            o[45] = x11 >>>  8 & 0xff;
            o[46] = x11 >>> 16 & 0xff;
            o[47] = x11 >>> 24 & 0xff;

            o[48] = x12 >>>  0 & 0xff;
            o[49] = x12 >>>  8 & 0xff;
            o[50] = x12 >>> 16 & 0xff;
            o[51] = x12 >>> 24 & 0xff;

            o[52] = x13 >>>  0 & 0xff;
            o[53] = x13 >>>  8 & 0xff;
            o[54] = x13 >>> 16 & 0xff;
            o[55] = x13 >>> 24 & 0xff;

            o[56] = x14 >>>  0 & 0xff;
            o[57] = x14 >>>  8 & 0xff;
            o[58] = x14 >>> 16 & 0xff;
            o[59] = x14 >>> 24 & 0xff;

            o[60] = x15 >>>  0 & 0xff;
            o[61] = x15 >>>  8 & 0xff;
            o[62] = x15 >>> 16 & 0xff;
            o[63] = x15 >>> 24 & 0xff;
          }

          function core_hsalsa20(o,p,k,c) {
            var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
              j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
              j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
              j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
              j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
              j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
              j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
              j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
              j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
              j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
              j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
              j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
              j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
              j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
              j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
              j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

            var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
              x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
              x15 = j15, u;

            for (var i = 0; i < 20; i += 2) {
              u = x0 + x12 | 0;
              x4 ^= u<<7 | u>>>(32-7);
              u = x4 + x0 | 0;
              x8 ^= u<<9 | u>>>(32-9);
              u = x8 + x4 | 0;
              x12 ^= u<<13 | u>>>(32-13);
              u = x12 + x8 | 0;
              x0 ^= u<<18 | u>>>(32-18);

              u = x5 + x1 | 0;
              x9 ^= u<<7 | u>>>(32-7);
              u = x9 + x5 | 0;
              x13 ^= u<<9 | u>>>(32-9);
              u = x13 + x9 | 0;
              x1 ^= u<<13 | u>>>(32-13);
              u = x1 + x13 | 0;
              x5 ^= u<<18 | u>>>(32-18);

              u = x10 + x6 | 0;
              x14 ^= u<<7 | u>>>(32-7);
              u = x14 + x10 | 0;
              x2 ^= u<<9 | u>>>(32-9);
              u = x2 + x14 | 0;
              x6 ^= u<<13 | u>>>(32-13);
              u = x6 + x2 | 0;
              x10 ^= u<<18 | u>>>(32-18);

              u = x15 + x11 | 0;
              x3 ^= u<<7 | u>>>(32-7);
              u = x3 + x15 | 0;
              x7 ^= u<<9 | u>>>(32-9);
              u = x7 + x3 | 0;
              x11 ^= u<<13 | u>>>(32-13);
              u = x11 + x7 | 0;
              x15 ^= u<<18 | u>>>(32-18);

              u = x0 + x3 | 0;
              x1 ^= u<<7 | u>>>(32-7);
              u = x1 + x0 | 0;
              x2 ^= u<<9 | u>>>(32-9);
              u = x2 + x1 | 0;
              x3 ^= u<<13 | u>>>(32-13);
              u = x3 + x2 | 0;
              x0 ^= u<<18 | u>>>(32-18);

              u = x5 + x4 | 0;
              x6 ^= u<<7 | u>>>(32-7);
              u = x6 + x5 | 0;
              x7 ^= u<<9 | u>>>(32-9);
              u = x7 + x6 | 0;
              x4 ^= u<<13 | u>>>(32-13);
              u = x4 + x7 | 0;
              x5 ^= u<<18 | u>>>(32-18);

              u = x10 + x9 | 0;
              x11 ^= u<<7 | u>>>(32-7);
              u = x11 + x10 | 0;
              x8 ^= u<<9 | u>>>(32-9);
              u = x8 + x11 | 0;
              x9 ^= u<<13 | u>>>(32-13);
              u = x9 + x8 | 0;
              x10 ^= u<<18 | u>>>(32-18);

              u = x15 + x14 | 0;
              x12 ^= u<<7 | u>>>(32-7);
              u = x12 + x15 | 0;
              x13 ^= u<<9 | u>>>(32-9);
              u = x13 + x12 | 0;
              x14 ^= u<<13 | u>>>(32-13);
              u = x14 + x13 | 0;
              x15 ^= u<<18 | u>>>(32-18);
            }

            o[ 0] = x0 >>>  0 & 0xff;
            o[ 1] = x0 >>>  8 & 0xff;
            o[ 2] = x0 >>> 16 & 0xff;
            o[ 3] = x0 >>> 24 & 0xff;

            o[ 4] = x5 >>>  0 & 0xff;
            o[ 5] = x5 >>>  8 & 0xff;
            o[ 6] = x5 >>> 16 & 0xff;
            o[ 7] = x5 >>> 24 & 0xff;

            o[ 8] = x10 >>>  0 & 0xff;
            o[ 9] = x10 >>>  8 & 0xff;
            o[10] = x10 >>> 16 & 0xff;
            o[11] = x10 >>> 24 & 0xff;

            o[12] = x15 >>>  0 & 0xff;
            o[13] = x15 >>>  8 & 0xff;
            o[14] = x15 >>> 16 & 0xff;
            o[15] = x15 >>> 24 & 0xff;

            o[16] = x6 >>>  0 & 0xff;
            o[17] = x6 >>>  8 & 0xff;
            o[18] = x6 >>> 16 & 0xff;
            o[19] = x6 >>> 24 & 0xff;

            o[20] = x7 >>>  0 & 0xff;
            o[21] = x7 >>>  8 & 0xff;
            o[22] = x7 >>> 16 & 0xff;
            o[23] = x7 >>> 24 & 0xff;

            o[24] = x8 >>>  0 & 0xff;
            o[25] = x8 >>>  8 & 0xff;
            o[26] = x8 >>> 16 & 0xff;
            o[27] = x8 >>> 24 & 0xff;

            o[28] = x9 >>>  0 & 0xff;
            o[29] = x9 >>>  8 & 0xff;
            o[30] = x9 >>> 16 & 0xff;
            o[31] = x9 >>> 24 & 0xff;
          }

          function crypto_core_salsa20(out,inp,k,c) {
            core_salsa20(out,inp,k,c);
          }

          function crypto_core_hsalsa20(out,inp,k,c) {
            core_hsalsa20(out,inp,k,c);
          }

          var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
          // "expand 32-byte k"

          function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
            var z = new Uint8Array(16), x = new Uint8Array(64);
            var u, i;
            for (i = 0; i < 16; i++) z[i] = 0;
            for (i = 0; i < 8; i++) z[i] = n[i];
            while (b >= 64) {
              crypto_core_salsa20(x,z,k,sigma);
              for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
              u = 1;
              for (i = 8; i < 16; i++) {
                u = u + (z[i] & 0xff) | 0;
                z[i] = u & 0xff;
                u >>>= 8;
              }
              b -= 64;
              cpos += 64;
              mpos += 64;
            }
            if (b > 0) {
              crypto_core_salsa20(x,z,k,sigma);
              for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
            }
            return 0;
          }

          function crypto_stream_salsa20(c,cpos,b,n,k) {
            var z = new Uint8Array(16), x = new Uint8Array(64);
            var u, i;
            for (i = 0; i < 16; i++) z[i] = 0;
            for (i = 0; i < 8; i++) z[i] = n[i];
            while (b >= 64) {
              crypto_core_salsa20(x,z,k,sigma);
              for (i = 0; i < 64; i++) c[cpos+i] = x[i];
              u = 1;
              for (i = 8; i < 16; i++) {
                u = u + (z[i] & 0xff) | 0;
                z[i] = u & 0xff;
                u >>>= 8;
              }
              b -= 64;
              cpos += 64;
            }
            if (b > 0) {
              crypto_core_salsa20(x,z,k,sigma);
              for (i = 0; i < b; i++) c[cpos+i] = x[i];
            }
            return 0;
          }

          function crypto_stream(c,cpos,d,n,k) {
            var s = new Uint8Array(32);
            crypto_core_hsalsa20(s,n,k,sigma);
            var sn = new Uint8Array(8);
            for (var i = 0; i < 8; i++) sn[i] = n[i+16];
            return crypto_stream_salsa20(c,cpos,d,sn,s);
          }

          function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
            var s = new Uint8Array(32);
            crypto_core_hsalsa20(s,n,k,sigma);
            var sn = new Uint8Array(8);
            for (var i = 0; i < 8; i++) sn[i] = n[i+16];
            return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
          }

          /*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

          var poly1305 = function(key) {
            this.buffer = new Uint8Array(16);
            this.r = new Uint16Array(10);
            this.h = new Uint16Array(10);
            this.pad = new Uint16Array(8);
            this.leftover = 0;
            this.fin = 0;

            var t0, t1, t2, t3, t4, t5, t6, t7;

            t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
            t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
            t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
            t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
            t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
            this.r[5] = ((t4 >>>  1)) & 0x1ffe;
            t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
            t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
            t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
            this.r[9] = ((t7 >>>  5)) & 0x007f;

            this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
            this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
            this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
            this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
            this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
            this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
            this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
            this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
          };

          poly1305.prototype.blocks = function(m, mpos, bytes) {
            var hibit = this.fin ? 0 : (1 << 11);
            var t0, t1, t2, t3, t4, t5, t6, t7, c;
            var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

            var h0 = this.h[0],
              h1 = this.h[1],
              h2 = this.h[2],
              h3 = this.h[3],
              h4 = this.h[4],
              h5 = this.h[5],
              h6 = this.h[6],
              h7 = this.h[7],
              h8 = this.h[8],
              h9 = this.h[9];

            var r0 = this.r[0],
              r1 = this.r[1],
              r2 = this.r[2],
              r3 = this.r[3],
              r4 = this.r[4],
              r5 = this.r[5],
              r6 = this.r[6],
              r7 = this.r[7],
              r8 = this.r[8],
              r9 = this.r[9];

            while (bytes >= 16) {
              t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
              t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
              t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
              t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
              t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
              h5 += ((t4 >>>  1)) & 0x1fff;
              t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
              t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
              t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
              h9 += ((t7 >>> 5)) | hibit;

              c = 0;

              d0 = c;
              d0 += h0 * r0;
              d0 += h1 * (5 * r9);
              d0 += h2 * (5 * r8);
              d0 += h3 * (5 * r7);
              d0 += h4 * (5 * r6);
              c = (d0 >>> 13); d0 &= 0x1fff;
              d0 += h5 * (5 * r5);
              d0 += h6 * (5 * r4);
              d0 += h7 * (5 * r3);
              d0 += h8 * (5 * r2);
              d0 += h9 * (5 * r1);
              c += (d0 >>> 13); d0 &= 0x1fff;

              d1 = c;
              d1 += h0 * r1;
              d1 += h1 * r0;
              d1 += h2 * (5 * r9);
              d1 += h3 * (5 * r8);
              d1 += h4 * (5 * r7);
              c = (d1 >>> 13); d1 &= 0x1fff;
              d1 += h5 * (5 * r6);
              d1 += h6 * (5 * r5);
              d1 += h7 * (5 * r4);
              d1 += h8 * (5 * r3);
              d1 += h9 * (5 * r2);
              c += (d1 >>> 13); d1 &= 0x1fff;

              d2 = c;
              d2 += h0 * r2;
              d2 += h1 * r1;
              d2 += h2 * r0;
              d2 += h3 * (5 * r9);
              d2 += h4 * (5 * r8);
              c = (d2 >>> 13); d2 &= 0x1fff;
              d2 += h5 * (5 * r7);
              d2 += h6 * (5 * r6);
              d2 += h7 * (5 * r5);
              d2 += h8 * (5 * r4);
              d2 += h9 * (5 * r3);
              c += (d2 >>> 13); d2 &= 0x1fff;

              d3 = c;
              d3 += h0 * r3;
              d3 += h1 * r2;
              d3 += h2 * r1;
              d3 += h3 * r0;
              d3 += h4 * (5 * r9);
              c = (d3 >>> 13); d3 &= 0x1fff;
              d3 += h5 * (5 * r8);
              d3 += h6 * (5 * r7);
              d3 += h7 * (5 * r6);
              d3 += h8 * (5 * r5);
              d3 += h9 * (5 * r4);
              c += (d3 >>> 13); d3 &= 0x1fff;

              d4 = c;
              d4 += h0 * r4;
              d4 += h1 * r3;
              d4 += h2 * r2;
              d4 += h3 * r1;
              d4 += h4 * r0;
              c = (d4 >>> 13); d4 &= 0x1fff;
              d4 += h5 * (5 * r9);
              d4 += h6 * (5 * r8);
              d4 += h7 * (5 * r7);
              d4 += h8 * (5 * r6);
              d4 += h9 * (5 * r5);
              c += (d4 >>> 13); d4 &= 0x1fff;

              d5 = c;
              d5 += h0 * r5;
              d5 += h1 * r4;
              d5 += h2 * r3;
              d5 += h3 * r2;
              d5 += h4 * r1;
              c = (d5 >>> 13); d5 &= 0x1fff;
              d5 += h5 * r0;
              d5 += h6 * (5 * r9);
              d5 += h7 * (5 * r8);
              d5 += h8 * (5 * r7);
              d5 += h9 * (5 * r6);
              c += (d5 >>> 13); d5 &= 0x1fff;

              d6 = c;
              d6 += h0 * r6;
              d6 += h1 * r5;
              d6 += h2 * r4;
              d6 += h3 * r3;
              d6 += h4 * r2;
              c = (d6 >>> 13); d6 &= 0x1fff;
              d6 += h5 * r1;
              d6 += h6 * r0;
              d6 += h7 * (5 * r9);
              d6 += h8 * (5 * r8);
              d6 += h9 * (5 * r7);
              c += (d6 >>> 13); d6 &= 0x1fff;

              d7 = c;
              d7 += h0 * r7;
              d7 += h1 * r6;
              d7 += h2 * r5;
              d7 += h3 * r4;
              d7 += h4 * r3;
              c = (d7 >>> 13); d7 &= 0x1fff;
              d7 += h5 * r2;
              d7 += h6 * r1;
              d7 += h7 * r0;
              d7 += h8 * (5 * r9);
              d7 += h9 * (5 * r8);
              c += (d7 >>> 13); d7 &= 0x1fff;

              d8 = c;
              d8 += h0 * r8;
              d8 += h1 * r7;
              d8 += h2 * r6;
              d8 += h3 * r5;
              d8 += h4 * r4;
              c = (d8 >>> 13); d8 &= 0x1fff;
              d8 += h5 * r3;
              d8 += h6 * r2;
              d8 += h7 * r1;
              d8 += h8 * r0;
              d8 += h9 * (5 * r9);
              c += (d8 >>> 13); d8 &= 0x1fff;

              d9 = c;
              d9 += h0 * r9;
              d9 += h1 * r8;
              d9 += h2 * r7;
              d9 += h3 * r6;
              d9 += h4 * r5;
              c = (d9 >>> 13); d9 &= 0x1fff;
              d9 += h5 * r4;
              d9 += h6 * r3;
              d9 += h7 * r2;
              d9 += h8 * r1;
              d9 += h9 * r0;
              c += (d9 >>> 13); d9 &= 0x1fff;

              c = (((c << 2) + c)) | 0;
              c = (c + d0) | 0;
              d0 = c & 0x1fff;
              c = (c >>> 13);
              d1 += c;

              h0 = d0;
              h1 = d1;
              h2 = d2;
              h3 = d3;
              h4 = d4;
              h5 = d5;
              h6 = d6;
              h7 = d7;
              h8 = d8;
              h9 = d9;

              mpos += 16;
              bytes -= 16;
            }
            this.h[0] = h0;
            this.h[1] = h1;
            this.h[2] = h2;
            this.h[3] = h3;
            this.h[4] = h4;
            this.h[5] = h5;
            this.h[6] = h6;
            this.h[7] = h7;
            this.h[8] = h8;
            this.h[9] = h9;
          };

          poly1305.prototype.finish = function(mac, macpos) {
            var g = new Uint16Array(10);
            var c, mask, f, i;

            if (this.leftover) {
              i = this.leftover;
              this.buffer[i++] = 1;
              for (; i < 16; i++) this.buffer[i] = 0;
              this.fin = 1;
              this.blocks(this.buffer, 0, 16);
            }

            c = this.h[1] >>> 13;
            this.h[1] &= 0x1fff;
            for (i = 2; i < 10; i++) {
              this.h[i] += c;
              c = this.h[i] >>> 13;
              this.h[i] &= 0x1fff;
            }
            this.h[0] += (c * 5);
            c = this.h[0] >>> 13;
            this.h[0] &= 0x1fff;
            this.h[1] += c;
            c = this.h[1] >>> 13;
            this.h[1] &= 0x1fff;
            this.h[2] += c;

            g[0] = this.h[0] + 5;
            c = g[0] >>> 13;
            g[0] &= 0x1fff;
            for (i = 1; i < 10; i++) {
              g[i] = this.h[i] + c;
              c = g[i] >>> 13;
              g[i] &= 0x1fff;
            }
            g[9] -= (1 << 13);

            mask = (c ^ 1) - 1;
            for (i = 0; i < 10; i++) g[i] &= mask;
            mask = ~mask;
            for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

            this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
            this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
            this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
            this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
            this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
            this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
            this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
            this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

            f = this.h[0] + this.pad[0];
            this.h[0] = f & 0xffff;
            for (i = 1; i < 8; i++) {
              f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
              this.h[i] = f & 0xffff;
            }

            mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
            mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
            mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
            mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
            mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
            mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
            mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
            mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
            mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
            mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
            mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
            mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
            mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
            mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
            mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
            mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
          };

          poly1305.prototype.update = function(m, mpos, bytes) {
            var i, want;

            if (this.leftover) {
              want = (16 - this.leftover);
              if (want > bytes)
                want = bytes;
              for (i = 0; i < want; i++)
                this.buffer[this.leftover + i] = m[mpos+i];
              bytes -= want;
              mpos += want;
              this.leftover += want;
              if (this.leftover < 16)
                return;
              this.blocks(this.buffer, 0, 16);
              this.leftover = 0;
            }

            if (bytes >= 16) {
              want = bytes - (bytes % 16);
              this.blocks(m, mpos, want);
              mpos += want;
              bytes -= want;
            }

            if (bytes) {
              for (i = 0; i < bytes; i++)
                this.buffer[this.leftover + i] = m[mpos+i];
              this.leftover += bytes;
            }
          };

          function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
            var s = new poly1305(k);
            s.update(m, mpos, n);
            s.finish(out, outpos);
            return 0;
          }

          function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
            var x = new Uint8Array(16);
            crypto_onetimeauth(x,0,m,mpos,n,k);
            return crypto_verify_16(h,hpos,x,0);
          }

          function crypto_secretbox(c,m,d,n,k) {
            var i;
            if (d < 32) return -1;
            crypto_stream_xor(c,0,m,0,d,n,k);
            crypto_onetimeauth(c, 16, c, 32, d - 32, c);
            for (i = 0; i < 16; i++) c[i] = 0;
            return 0;
          }

          function crypto_secretbox_open(m,c,d,n,k) {
            var i;
            var x = new Uint8Array(32);
            if (d < 32) return -1;
            crypto_stream(x,0,32,n,k);
            if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
            crypto_stream_xor(m,0,c,0,d,n,k);
            for (i = 0; i < 32; i++) m[i] = 0;
            return 0;
          }

          function set25519(r, a) {
            var i;
            for (i = 0; i < 16; i++) r[i] = a[i]|0;
          }

          function car25519(o) {
            var i, v, c = 1;
            for (i = 0; i < 16; i++) {
              v = o[i] + c + 65535;
              c = Math.floor(v / 65536);
              o[i] = v - c * 65536;
            }
            o[0] += c-1 + 37 * (c-1);
          }

          function sel25519(p, q, b) {
            var t, c = ~(b-1);
            for (var i = 0; i < 16; i++) {
              t = c & (p[i] ^ q[i]);
              p[i] ^= t;
              q[i] ^= t;
            }
          }

          function pack25519(o, n) {
            var i, j, b;
            var m = gf(), t = gf();
            for (i = 0; i < 16; i++) t[i] = n[i];
            car25519(t);
            car25519(t);
            car25519(t);
            for (j = 0; j < 2; j++) {
              m[0] = t[0] - 0xffed;
              for (i = 1; i < 15; i++) {
                m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
                m[i-1] &= 0xffff;
              }
              m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
              b = (m[15]>>16) & 1;
              m[14] &= 0xffff;
              sel25519(t, m, 1-b);
            }
            for (i = 0; i < 16; i++) {
              o[2*i] = t[i] & 0xff;
              o[2*i+1] = t[i]>>8;
            }
          }

          function neq25519(a, b) {
            var c = new Uint8Array(32), d = new Uint8Array(32);
            pack25519(c, a);
            pack25519(d, b);
            return crypto_verify_32(c, 0, d, 0);
          }

          function par25519(a) {
            var d = new Uint8Array(32);
            pack25519(d, a);
            return d[0] & 1;
          }

          function unpack25519(o, n) {
            var i;
            for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
            o[15] &= 0x7fff;
          }

          function A(o, a, b) {
            for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
          }

          function Z(o, a, b) {
            for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
          }

          function M(o, a, b) {
            var v, c,
              t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
              t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
              t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
              t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
              b0 = b[0],
              b1 = b[1],
              b2 = b[2],
              b3 = b[3],
              b4 = b[4],
              b5 = b[5],
              b6 = b[6],
              b7 = b[7],
              b8 = b[8],
              b9 = b[9],
              b10 = b[10],
              b11 = b[11],
              b12 = b[12],
              b13 = b[13],
              b14 = b[14],
              b15 = b[15];

            v = a[0];
            t0 += v * b0;
            t1 += v * b1;
            t2 += v * b2;
            t3 += v * b3;
            t4 += v * b4;
            t5 += v * b5;
            t6 += v * b6;
            t7 += v * b7;
            t8 += v * b8;
            t9 += v * b9;
            t10 += v * b10;
            t11 += v * b11;
            t12 += v * b12;
            t13 += v * b13;
            t14 += v * b14;
            t15 += v * b15;
            v = a[1];
            t1 += v * b0;
            t2 += v * b1;
            t3 += v * b2;
            t4 += v * b3;
            t5 += v * b4;
            t6 += v * b5;
            t7 += v * b6;
            t8 += v * b7;
            t9 += v * b8;
            t10 += v * b9;
            t11 += v * b10;
            t12 += v * b11;
            t13 += v * b12;
            t14 += v * b13;
            t15 += v * b14;
            t16 += v * b15;
            v = a[2];
            t2 += v * b0;
            t3 += v * b1;
            t4 += v * b2;
            t5 += v * b3;
            t6 += v * b4;
            t7 += v * b5;
            t8 += v * b6;
            t9 += v * b7;
            t10 += v * b8;
            t11 += v * b9;
            t12 += v * b10;
            t13 += v * b11;
            t14 += v * b12;
            t15 += v * b13;
            t16 += v * b14;
            t17 += v * b15;
            v = a[3];
            t3 += v * b0;
            t4 += v * b1;
            t5 += v * b2;
            t6 += v * b3;
            t7 += v * b4;
            t8 += v * b5;
            t9 += v * b6;
            t10 += v * b7;
            t11 += v * b8;
            t12 += v * b9;
            t13 += v * b10;
            t14 += v * b11;
            t15 += v * b12;
            t16 += v * b13;
            t17 += v * b14;
            t18 += v * b15;
            v = a[4];
            t4 += v * b0;
            t5 += v * b1;
            t6 += v * b2;
            t7 += v * b3;
            t8 += v * b4;
            t9 += v * b5;
            t10 += v * b6;
            t11 += v * b7;
            t12 += v * b8;
            t13 += v * b9;
            t14 += v * b10;
            t15 += v * b11;
            t16 += v * b12;
            t17 += v * b13;
            t18 += v * b14;
            t19 += v * b15;
            v = a[5];
            t5 += v * b0;
            t6 += v * b1;
            t7 += v * b2;
            t8 += v * b3;
            t9 += v * b4;
            t10 += v * b5;
            t11 += v * b6;
            t12 += v * b7;
            t13 += v * b8;
            t14 += v * b9;
            t15 += v * b10;
            t16 += v * b11;
            t17 += v * b12;
            t18 += v * b13;
            t19 += v * b14;
            t20 += v * b15;
            v = a[6];
            t6 += v * b0;
            t7 += v * b1;
            t8 += v * b2;
            t9 += v * b3;
            t10 += v * b4;
            t11 += v * b5;
            t12 += v * b6;
            t13 += v * b7;
            t14 += v * b8;
            t15 += v * b9;
            t16 += v * b10;
            t17 += v * b11;
            t18 += v * b12;
            t19 += v * b13;
            t20 += v * b14;
            t21 += v * b15;
            v = a[7];
            t7 += v * b0;
            t8 += v * b1;
            t9 += v * b2;
            t10 += v * b3;
            t11 += v * b4;
            t12 += v * b5;
            t13 += v * b6;
            t14 += v * b7;
            t15 += v * b8;
            t16 += v * b9;
            t17 += v * b10;
            t18 += v * b11;
            t19 += v * b12;
            t20 += v * b13;
            t21 += v * b14;
            t22 += v * b15;
            v = a[8];
            t8 += v * b0;
            t9 += v * b1;
            t10 += v * b2;
            t11 += v * b3;
            t12 += v * b4;
            t13 += v * b5;
            t14 += v * b6;
            t15 += v * b7;
            t16 += v * b8;
            t17 += v * b9;
            t18 += v * b10;
            t19 += v * b11;
            t20 += v * b12;
            t21 += v * b13;
            t22 += v * b14;
            t23 += v * b15;
            v = a[9];
            t9 += v * b0;
            t10 += v * b1;
            t11 += v * b2;
            t12 += v * b3;
            t13 += v * b4;
            t14 += v * b5;
            t15 += v * b6;
            t16 += v * b7;
            t17 += v * b8;
            t18 += v * b9;
            t19 += v * b10;
            t20 += v * b11;
            t21 += v * b12;
            t22 += v * b13;
            t23 += v * b14;
            t24 += v * b15;
            v = a[10];
            t10 += v * b0;
            t11 += v * b1;
            t12 += v * b2;
            t13 += v * b3;
            t14 += v * b4;
            t15 += v * b5;
            t16 += v * b6;
            t17 += v * b7;
            t18 += v * b8;
            t19 += v * b9;
            t20 += v * b10;
            t21 += v * b11;
            t22 += v * b12;
            t23 += v * b13;
            t24 += v * b14;
            t25 += v * b15;
            v = a[11];
            t11 += v * b0;
            t12 += v * b1;
            t13 += v * b2;
            t14 += v * b3;
            t15 += v * b4;
            t16 += v * b5;
            t17 += v * b6;
            t18 += v * b7;
            t19 += v * b8;
            t20 += v * b9;
            t21 += v * b10;
            t22 += v * b11;
            t23 += v * b12;
            t24 += v * b13;
            t25 += v * b14;
            t26 += v * b15;
            v = a[12];
            t12 += v * b0;
            t13 += v * b1;
            t14 += v * b2;
            t15 += v * b3;
            t16 += v * b4;
            t17 += v * b5;
            t18 += v * b6;
            t19 += v * b7;
            t20 += v * b8;
            t21 += v * b9;
            t22 += v * b10;
            t23 += v * b11;
            t24 += v * b12;
            t25 += v * b13;
            t26 += v * b14;
            t27 += v * b15;
            v = a[13];
            t13 += v * b0;
            t14 += v * b1;
            t15 += v * b2;
            t16 += v * b3;
            t17 += v * b4;
            t18 += v * b5;
            t19 += v * b6;
            t20 += v * b7;
            t21 += v * b8;
            t22 += v * b9;
            t23 += v * b10;
            t24 += v * b11;
            t25 += v * b12;
            t26 += v * b13;
            t27 += v * b14;
            t28 += v * b15;
            v = a[14];
            t14 += v * b0;
            t15 += v * b1;
            t16 += v * b2;
            t17 += v * b3;
            t18 += v * b4;
            t19 += v * b5;
            t20 += v * b6;
            t21 += v * b7;
            t22 += v * b8;
            t23 += v * b9;
            t24 += v * b10;
            t25 += v * b11;
            t26 += v * b12;
            t27 += v * b13;
            t28 += v * b14;
            t29 += v * b15;
            v = a[15];
            t15 += v * b0;
            t16 += v * b1;
            t17 += v * b2;
            t18 += v * b3;
            t19 += v * b4;
            t20 += v * b5;
            t21 += v * b6;
            t22 += v * b7;
            t23 += v * b8;
            t24 += v * b9;
            t25 += v * b10;
            t26 += v * b11;
            t27 += v * b12;
            t28 += v * b13;
            t29 += v * b14;
            t30 += v * b15;

            t0  += 38 * t16;
            t1  += 38 * t17;
            t2  += 38 * t18;
            t3  += 38 * t19;
            t4  += 38 * t20;
            t5  += 38 * t21;
            t6  += 38 * t22;
            t7  += 38 * t23;
            t8  += 38 * t24;
            t9  += 38 * t25;
            t10 += 38 * t26;
            t11 += 38 * t27;
            t12 += 38 * t28;
            t13 += 38 * t29;
            t14 += 38 * t30;
            // t15 left as is

            // first car
            c = 1;
            v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
            v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
            v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
            v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
            v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
            v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
            v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
            v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
            v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
            v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
            v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
            v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
            v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
            v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
            v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
            v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
            t0 += c-1 + 37 * (c-1);

            // second car
            c = 1;
            v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
            v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
            v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
            v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
            v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
            v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
            v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
            v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
            v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
            v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
            v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
            v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
            v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
            v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
            v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
            v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
            t0 += c-1 + 37 * (c-1);

            o[ 0] = t0;
            o[ 1] = t1;
            o[ 2] = t2;
            o[ 3] = t3;
            o[ 4] = t4;
            o[ 5] = t5;
            o[ 6] = t6;
            o[ 7] = t7;
            o[ 8] = t8;
            o[ 9] = t9;
            o[10] = t10;
            o[11] = t11;
            o[12] = t12;
            o[13] = t13;
            o[14] = t14;
            o[15] = t15;
          }

          function S(o, a) {
            M(o, a, a);
          }

          function inv25519(o, i) {
            var c = gf();
            var a;
            for (a = 0; a < 16; a++) c[a] = i[a];
            for (a = 253; a >= 0; a--) {
              S(c, c);
              if(a !== 2 && a !== 4) M(c, c, i);
            }
            for (a = 0; a < 16; a++) o[a] = c[a];
          }

          function pow2523(o, i) {
            var c = gf();
            var a;
            for (a = 0; a < 16; a++) c[a] = i[a];
            for (a = 250; a >= 0; a--) {
              S(c, c);
              if(a !== 1) M(c, c, i);
            }
            for (a = 0; a < 16; a++) o[a] = c[a];
          }

          function crypto_scalarmult(q, n, p) {
            var z = new Uint8Array(32);
            var x = new Float64Array(80), r, i;
            var a = gf(), b = gf(), c = gf(),
              d = gf(), e = gf(), f = gf();
            for (i = 0; i < 31; i++) z[i] = n[i];
            z[31]=(n[31]&127)|64;
            z[0]&=248;
            unpack25519(x,p);
            for (i = 0; i < 16; i++) {
              b[i]=x[i];
              d[i]=a[i]=c[i]=0;
            }
            a[0]=d[0]=1;
            for (i=254; i>=0; --i) {
              r=(z[i>>>3]>>>(i&7))&1;
              sel25519(a,b,r);
              sel25519(c,d,r);
              A(e,a,c);
              Z(a,a,c);
              A(c,b,d);
              Z(b,b,d);
              S(d,e);
              S(f,a);
              M(a,c,a);
              M(c,b,e);
              A(e,a,c);
              Z(a,a,c);
              S(b,a);
              Z(c,d,f);
              M(a,c,_121665);
              A(a,a,d);
              M(c,c,a);
              M(a,d,f);
              M(d,b,x);
              S(b,e);
              sel25519(a,b,r);
              sel25519(c,d,r);
            }
            for (i = 0; i < 16; i++) {
              x[i+16]=a[i];
              x[i+32]=c[i];
              x[i+48]=b[i];
              x[i+64]=d[i];
            }
            var x32 = x.subarray(32);
            var x16 = x.subarray(16);
            inv25519(x32,x32);
            M(x16,x16,x32);
            pack25519(q,x16);
            return 0;
          }

          function crypto_scalarmult_base(q, n) {
            return crypto_scalarmult(q, n, _9);
          }

          function crypto_box_keypair(y, x) {
            randombytes(x, 32);
            return crypto_scalarmult_base(y, x);
          }

          function crypto_box_beforenm(k, y, x) {
            var s = new Uint8Array(32);
            crypto_scalarmult(s, x, y);
            return crypto_core_hsalsa20(k, _0, s, sigma);
          }

          var crypto_box_afternm = crypto_secretbox;
          var crypto_box_open_afternm = crypto_secretbox_open;

          function crypto_box(c, m, d, n, y, x) {
            var k = new Uint8Array(32);
            crypto_box_beforenm(k, y, x);
            return crypto_box_afternm(c, m, d, n, k);
          }

          function crypto_box_open(m, c, d, n, y, x) {
            var k = new Uint8Array(32);
            crypto_box_beforenm(k, y, x);
            return crypto_box_open_afternm(m, c, d, n, k);
          }

          var K = [
            0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
            0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
            0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
            0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
            0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
            0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
            0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
            0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
            0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
            0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
            0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
            0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
            0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
            0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
            0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
            0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
            0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
            0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
            0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
            0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
            0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
            0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
            0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
            0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
            0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
            0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
            0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
            0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
            0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
            0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
            0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
            0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
            0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
            0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
            0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
            0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
            0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
            0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
            0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
            0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
          ];

          function crypto_hashblocks_hl(hh, hl, m, n) {
            var wh = new Int32Array(16), wl = new Int32Array(16),
              bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
              bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
              th, tl, i, j, h, l, a, b, c, d;

            var ah0 = hh[0],
              ah1 = hh[1],
              ah2 = hh[2],
              ah3 = hh[3],
              ah4 = hh[4],
              ah5 = hh[5],
              ah6 = hh[6],
              ah7 = hh[7],

              al0 = hl[0],
              al1 = hl[1],
              al2 = hl[2],
              al3 = hl[3],
              al4 = hl[4],
              al5 = hl[5],
              al6 = hl[6],
              al7 = hl[7];

            var pos = 0;
            while (n >= 128) {
              for (i = 0; i < 16; i++) {
                j = 8 * i + pos;
                wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
                wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
              }
              for (i = 0; i < 80; i++) {
                bh0 = ah0;
                bh1 = ah1;
                bh2 = ah2;
                bh3 = ah3;
                bh4 = ah4;
                bh5 = ah5;
                bh6 = ah6;
                bh7 = ah7;

                bl0 = al0;
                bl1 = al1;
                bl2 = al2;
                bl3 = al3;
                bl4 = al4;
                bl5 = al5;
                bl6 = al6;
                bl7 = al7;

                // add
                h = ah7;
                l = al7;

                a = l & 0xffff; b = l >>> 16;
                c = h & 0xffff; d = h >>> 16;

                // Sigma1
                h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
                l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

                a += l & 0xffff; b += l >>> 16;
                c += h & 0xffff; d += h >>> 16;

                // Ch
                h = (ah4 & ah5) ^ (~ah4 & ah6);
                l = (al4 & al5) ^ (~al4 & al6);

                a += l & 0xffff; b += l >>> 16;
                c += h & 0xffff; d += h >>> 16;

                // K
                h = K[i*2];
                l = K[i*2+1];

                a += l & 0xffff; b += l >>> 16;
                c += h & 0xffff; d += h >>> 16;

                // w
                h = wh[i%16];
                l = wl[i%16];

                a += l & 0xffff; b += l >>> 16;
                c += h & 0xffff; d += h >>> 16;

                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;

                th = c & 0xffff | d << 16;
                tl = a & 0xffff | b << 16;

                // add
                h = th;
                l = tl;

                a = l & 0xffff; b = l >>> 16;
                c = h & 0xffff; d = h >>> 16;

                // Sigma0
                h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
                l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

                a += l & 0xffff; b += l >>> 16;
                c += h & 0xffff; d += h >>> 16;

                // Maj
                h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
                l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

                a += l & 0xffff; b += l >>> 16;
                c += h & 0xffff; d += h >>> 16;

                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;

                bh7 = (c & 0xffff) | (d << 16);
                bl7 = (a & 0xffff) | (b << 16);

                // add
                h = bh3;
                l = bl3;

                a = l & 0xffff; b = l >>> 16;
                c = h & 0xffff; d = h >>> 16;

                h = th;
                l = tl;

                a += l & 0xffff; b += l >>> 16;
                c += h & 0xffff; d += h >>> 16;

                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;

                bh3 = (c & 0xffff) | (d << 16);
                bl3 = (a & 0xffff) | (b << 16);

                ah1 = bh0;
                ah2 = bh1;
                ah3 = bh2;
                ah4 = bh3;
                ah5 = bh4;
                ah6 = bh5;
                ah7 = bh6;
                ah0 = bh7;

                al1 = bl0;
                al2 = bl1;
                al3 = bl2;
                al4 = bl3;
                al5 = bl4;
                al6 = bl5;
                al7 = bl6;
                al0 = bl7;

                if (i%16 === 15) {
                  for (j = 0; j < 16; j++) {
                    // add
                    h = wh[j];
                    l = wl[j];

                    a = l & 0xffff; b = l >>> 16;
                    c = h & 0xffff; d = h >>> 16;

                    h = wh[(j+9)%16];
                    l = wl[(j+9)%16];

                    a += l & 0xffff; b += l >>> 16;
                    c += h & 0xffff; d += h >>> 16;

                    // sigma0
                    th = wh[(j+1)%16];
                    tl = wl[(j+1)%16];
                    h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
                    l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

                    a += l & 0xffff; b += l >>> 16;
                    c += h & 0xffff; d += h >>> 16;

                    // sigma1
                    th = wh[(j+14)%16];
                    tl = wl[(j+14)%16];
                    h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
                    l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

                    a += l & 0xffff; b += l >>> 16;
                    c += h & 0xffff; d += h >>> 16;

                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;

                    wh[j] = (c & 0xffff) | (d << 16);
                    wl[j] = (a & 0xffff) | (b << 16);
                  }
                }
              }

              // add
              h = ah0;
              l = al0;

              a = l & 0xffff; b = l >>> 16;
              c = h & 0xffff; d = h >>> 16;

              h = hh[0];
              l = hl[0];

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;

              hh[0] = ah0 = (c & 0xffff) | (d << 16);
              hl[0] = al0 = (a & 0xffff) | (b << 16);

              h = ah1;
              l = al1;

              a = l & 0xffff; b = l >>> 16;
              c = h & 0xffff; d = h >>> 16;

              h = hh[1];
              l = hl[1];

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;

              hh[1] = ah1 = (c & 0xffff) | (d << 16);
              hl[1] = al1 = (a & 0xffff) | (b << 16);

              h = ah2;
              l = al2;

              a = l & 0xffff; b = l >>> 16;
              c = h & 0xffff; d = h >>> 16;

              h = hh[2];
              l = hl[2];

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;

              hh[2] = ah2 = (c & 0xffff) | (d << 16);
              hl[2] = al2 = (a & 0xffff) | (b << 16);

              h = ah3;
              l = al3;

              a = l & 0xffff; b = l >>> 16;
              c = h & 0xffff; d = h >>> 16;

              h = hh[3];
              l = hl[3];

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;

              hh[3] = ah3 = (c & 0xffff) | (d << 16);
              hl[3] = al3 = (a & 0xffff) | (b << 16);

              h = ah4;
              l = al4;

              a = l & 0xffff; b = l >>> 16;
              c = h & 0xffff; d = h >>> 16;

              h = hh[4];
              l = hl[4];

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;

              hh[4] = ah4 = (c & 0xffff) | (d << 16);
              hl[4] = al4 = (a & 0xffff) | (b << 16);

              h = ah5;
              l = al5;

              a = l & 0xffff; b = l >>> 16;
              c = h & 0xffff; d = h >>> 16;

              h = hh[5];
              l = hl[5];

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;

              hh[5] = ah5 = (c & 0xffff) | (d << 16);
              hl[5] = al5 = (a & 0xffff) | (b << 16);

              h = ah6;
              l = al6;

              a = l & 0xffff; b = l >>> 16;
              c = h & 0xffff; d = h >>> 16;

              h = hh[6];
              l = hl[6];

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;

              hh[6] = ah6 = (c & 0xffff) | (d << 16);
              hl[6] = al6 = (a & 0xffff) | (b << 16);

              h = ah7;
              l = al7;

              a = l & 0xffff; b = l >>> 16;
              c = h & 0xffff; d = h >>> 16;

              h = hh[7];
              l = hl[7];

              a += l & 0xffff; b += l >>> 16;
              c += h & 0xffff; d += h >>> 16;

              b += a >>> 16;
              c += b >>> 16;
              d += c >>> 16;

              hh[7] = ah7 = (c & 0xffff) | (d << 16);
              hl[7] = al7 = (a & 0xffff) | (b << 16);

              pos += 128;
              n -= 128;
            }

            return n;
          }

          function crypto_hash(out, m, n) {
            var hh = new Int32Array(8),
              hl = new Int32Array(8),
              x = new Uint8Array(256),
              i, b = n;

            hh[0] = 0x6a09e667;
            hh[1] = 0xbb67ae85;
            hh[2] = 0x3c6ef372;
            hh[3] = 0xa54ff53a;
            hh[4] = 0x510e527f;
            hh[5] = 0x9b05688c;
            hh[6] = 0x1f83d9ab;
            hh[7] = 0x5be0cd19;

            hl[0] = 0xf3bcc908;
            hl[1] = 0x84caa73b;
            hl[2] = 0xfe94f82b;
            hl[3] = 0x5f1d36f1;
            hl[4] = 0xade682d1;
            hl[5] = 0x2b3e6c1f;
            hl[6] = 0xfb41bd6b;
            hl[7] = 0x137e2179;

            crypto_hashblocks_hl(hh, hl, m, n);
            n %= 128;

            for (i = 0; i < n; i++) x[i] = m[b-n+i];
            x[n] = 128;

            n = 256-128*(n<112?1:0);
            x[n-9] = 0;
            ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
            crypto_hashblocks_hl(hh, hl, x, n);

            for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

            return 0;
          }

          function add(p, q) {
            var a = gf(), b = gf(), c = gf(),
              d = gf(), e = gf(), f = gf(),
              g = gf(), h = gf(), t = gf();

            Z(a, p[1], p[0]);
            Z(t, q[1], q[0]);
            M(a, a, t);
            A(b, p[0], p[1]);
            A(t, q[0], q[1]);
            M(b, b, t);
            M(c, p[3], q[3]);
            M(c, c, D2);
            M(d, p[2], q[2]);
            A(d, d, d);
            Z(e, b, a);
            Z(f, d, c);
            A(g, d, c);
            A(h, b, a);

            M(p[0], e, f);
            M(p[1], h, g);
            M(p[2], g, f);
            M(p[3], e, h);
          }

          function cswap(p, q, b) {
            var i;
            for (i = 0; i < 4; i++) {
              sel25519(p[i], q[i], b);
            }
          }

          function pack(r, p) {
            var tx = gf(), ty = gf(), zi = gf();
            inv25519(zi, p[2]);
            M(tx, p[0], zi);
            M(ty, p[1], zi);
            pack25519(r, ty);
            r[31] ^= par25519(tx) << 7;
          }

          function scalarmult(p, q, s) {
            var b, i;
            set25519(p[0], gf0);
            set25519(p[1], gf1);
            set25519(p[2], gf1);
            set25519(p[3], gf0);
            for (i = 255; i >= 0; --i) {
              b = (s[(i/8)|0] >> (i&7)) & 1;
              cswap(p, q, b);
              add(q, p);
              add(p, p);
              cswap(p, q, b);
            }
          }

          function scalarbase(p, s) {
            var q = [gf(), gf(), gf(), gf()];
            set25519(q[0], X);
            set25519(q[1], Y);
            set25519(q[2], gf1);
            M(q[3], X, Y);
            scalarmult(p, q, s);
          }

          function crypto_sign_keypair(pk, sk, seeded) {
            var d = new Uint8Array(64);
            var p = [gf(), gf(), gf(), gf()];
            var i;

            if (!seeded) randombytes(sk, 32);
            crypto_hash(d, sk, 32);
            d[0] &= 248;
            d[31] &= 127;
            d[31] |= 64;

            scalarbase(p, d);
            pack(pk, p);

            for (i = 0; i < 32; i++) sk[i+32] = pk[i];
            return 0;
          }

          var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

          function modL(r, x) {
            var carry, i, j, k;
            for (i = 63; i >= 32; --i) {
              carry = 0;
              for (j = i - 32, k = i - 12; j < k; ++j) {
                x[j] += carry - 16 * x[i] * L[j - (i - 32)];
                carry = (x[j] + 128) >> 8;
                x[j] -= carry * 256;
              }
              x[j] += carry;
              x[i] = 0;
            }
            carry = 0;
            for (j = 0; j < 32; j++) {
              x[j] += carry - (x[31] >> 4) * L[j];
              carry = x[j] >> 8;
              x[j] &= 255;
            }
            for (j = 0; j < 32; j++) x[j] -= carry * L[j];
            for (i = 0; i < 32; i++) {
              x[i+1] += x[i] >> 8;
              r[i] = x[i] & 255;
            }
          }

          function reduce(r) {
            var x = new Float64Array(64), i;
            for (i = 0; i < 64; i++) x[i] = r[i];
            for (i = 0; i < 64; i++) r[i] = 0;
            modL(r, x);
          }

// Note: difference from C - smlen returned, not passed as argument.
          function crypto_sign(sm, m, n, sk) {
            var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
            var i, j, x = new Float64Array(64);
            var p = [gf(), gf(), gf(), gf()];

            crypto_hash(d, sk, 32);
            d[0] &= 248;
            d[31] &= 127;
            d[31] |= 64;

            var smlen = n + 64;
            for (i = 0; i < n; i++) sm[64 + i] = m[i];
            for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

            crypto_hash(r, sm.subarray(32), n+32);
            reduce(r);
            scalarbase(p, r);
            pack(sm, p);

            for (i = 32; i < 64; i++) sm[i] = sk[i];
            crypto_hash(h, sm, n + 64);
            reduce(h);

            for (i = 0; i < 64; i++) x[i] = 0;
            for (i = 0; i < 32; i++) x[i] = r[i];
            for (i = 0; i < 32; i++) {
              for (j = 0; j < 32; j++) {
                x[i+j] += h[i] * d[j];
              }
            }

            modL(sm.subarray(32), x);
            return smlen;
          }

          function unpackneg(r, p) {
            var t = gf(), chk = gf(), num = gf(),
              den = gf(), den2 = gf(), den4 = gf(),
              den6 = gf();

            set25519(r[2], gf1);
            unpack25519(r[1], p);
            S(num, r[1]);
            M(den, num, D);
            Z(num, num, r[2]);
            A(den, r[2], den);

            S(den2, den);
            S(den4, den2);
            M(den6, den4, den2);
            M(t, den6, num);
            M(t, t, den);

            pow2523(t, t);
            M(t, t, num);
            M(t, t, den);
            M(t, t, den);
            M(r[0], t, den);

            S(chk, r[0]);
            M(chk, chk, den);
            if (neq25519(chk, num)) M(r[0], r[0], I);

            S(chk, r[0]);
            M(chk, chk, den);
            if (neq25519(chk, num)) return -1;

            if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

            M(r[3], r[0], r[1]);
            return 0;
          }

          function crypto_sign_open(m, sm, n, pk) {
            var i, mlen;
            var t = new Uint8Array(32), h = new Uint8Array(64);
            var p = [gf(), gf(), gf(), gf()],
              q = [gf(), gf(), gf(), gf()];

            mlen = -1;
            if (n < 64) return -1;

            if (unpackneg(q, pk)) return -1;

            for (i = 0; i < n; i++) m[i] = sm[i];
            for (i = 0; i < 32; i++) m[i+32] = pk[i];
            crypto_hash(h, m, n);
            reduce(h);
            scalarmult(p, q, h);

            scalarbase(q, sm.subarray(32));
            add(p, q);
            pack(t, p);

            n -= 64;
            if (crypto_verify_32(sm, 0, t, 0)) {
              for (i = 0; i < n; i++) m[i] = 0;
              return -1;
            }

            for (i = 0; i < n; i++) m[i] = sm[i + 64];
            mlen = n;
            return mlen;
          }

          var crypto_secretbox_KEYBYTES = 32,
            crypto_secretbox_NONCEBYTES = 24,
            crypto_secretbox_ZEROBYTES = 32,
            crypto_secretbox_BOXZEROBYTES = 16,
            crypto_scalarmult_BYTES = 32,
            crypto_scalarmult_SCALARBYTES = 32,
            crypto_box_PUBLICKEYBYTES = 32,
            crypto_box_SECRETKEYBYTES = 32,
            crypto_box_BEFORENMBYTES = 32,
            crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
            crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
            crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
            crypto_sign_BYTES = 64,
            crypto_sign_PUBLICKEYBYTES = 32,
            crypto_sign_SECRETKEYBYTES = 64,
            crypto_sign_SEEDBYTES = 32,
            crypto_hash_BYTES = 64;

          nacl.lowlevel = {
            crypto_core_hsalsa20: crypto_core_hsalsa20,
            crypto_stream_xor: crypto_stream_xor,
            crypto_stream: crypto_stream,
            crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
            crypto_stream_salsa20: crypto_stream_salsa20,
            crypto_onetimeauth: crypto_onetimeauth,
            crypto_onetimeauth_verify: crypto_onetimeauth_verify,
            crypto_verify_16: crypto_verify_16,
            crypto_verify_32: crypto_verify_32,
            crypto_secretbox: crypto_secretbox,
            crypto_secretbox_open: crypto_secretbox_open,
            crypto_scalarmult: crypto_scalarmult,
            crypto_scalarmult_base: crypto_scalarmult_base,
            crypto_box_beforenm: crypto_box_beforenm,
            crypto_box_afternm: crypto_box_afternm,
            crypto_box: crypto_box,
            crypto_box_open: crypto_box_open,
            crypto_box_keypair: crypto_box_keypair,
            crypto_hash: crypto_hash,
            crypto_sign: crypto_sign,
            crypto_sign_keypair: crypto_sign_keypair,
            crypto_sign_open: crypto_sign_open,

            crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
            crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
            crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
            crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
            crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
            crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
            crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
            crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
            crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
            crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
            crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
            crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
            crypto_sign_BYTES: crypto_sign_BYTES,
            crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
            crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
            crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
            crypto_hash_BYTES: crypto_hash_BYTES
          };

          /* High-level API */

          function checkLengths(k, n) {
            if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
            if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
          }

          function checkBoxLengths(pk, sk) {
            if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
            if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
          }

          function checkArrayTypes() {
            for (var i = 0; i < arguments.length; i++) {
              if (!(arguments[i] instanceof Uint8Array))
                throw new TypeError('unexpected type, use Uint8Array');
            }
          }

          function cleanup(arr) {
            for (var i = 0; i < arr.length; i++) arr[i] = 0;
          }

          nacl.randomBytes = function(n) {
            var b = new Uint8Array(n);
            randombytes(b, n);
            return b;
          };

          nacl.secretbox = function(msg, nonce, key) {
            checkArrayTypes(msg, nonce, key);
            checkLengths(key, nonce);
            var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
            var c = new Uint8Array(m.length);
            for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
            crypto_secretbox(c, m, m.length, nonce, key);
            return c.subarray(crypto_secretbox_BOXZEROBYTES);
          };

          nacl.secretbox.open = function(box, nonce, key) {
            checkArrayTypes(box, nonce, key);
            checkLengths(key, nonce);
            var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
            var m = new Uint8Array(c.length);
            for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
            if (c.length < 32) return null;
            if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return null;
            return m.subarray(crypto_secretbox_ZEROBYTES);
          };

          nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
          nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
          nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

          nacl.scalarMult = function(n, p) {
            checkArrayTypes(n, p);
            if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
            if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
            var q = new Uint8Array(crypto_scalarmult_BYTES);
            crypto_scalarmult(q, n, p);
            return q;
          };

          nacl.scalarMult.base = function(n) {
            checkArrayTypes(n);
            if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
            var q = new Uint8Array(crypto_scalarmult_BYTES);
            crypto_scalarmult_base(q, n);
            return q;
          };

          nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
          nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

          nacl.box = function(msg, nonce, publicKey, secretKey) {
            var k = nacl.box.before(publicKey, secretKey);
            return nacl.secretbox(msg, nonce, k);
          };

          nacl.box.before = function(publicKey, secretKey) {
            checkArrayTypes(publicKey, secretKey);
            checkBoxLengths(publicKey, secretKey);
            var k = new Uint8Array(crypto_box_BEFORENMBYTES);
            crypto_box_beforenm(k, publicKey, secretKey);
            return k;
          };

          nacl.box.after = nacl.secretbox;

          nacl.box.open = function(msg, nonce, publicKey, secretKey) {
            var k = nacl.box.before(publicKey, secretKey);
            return nacl.secretbox.open(msg, nonce, k);
          };

          nacl.box.open.after = nacl.secretbox.open;

          nacl.box.keyPair = function() {
            var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
            var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
            crypto_box_keypair(pk, sk);
            return {publicKey: pk, secretKey: sk};
          };

          nacl.box.keyPair.fromSecretKey = function(secretKey) {
            checkArrayTypes(secretKey);
            if (secretKey.length !== crypto_box_SECRETKEYBYTES)
              throw new Error('bad secret key size');
            var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
            crypto_scalarmult_base(pk, secretKey);
            return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
          };

          nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
          nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
          nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
          nacl.box.nonceLength = crypto_box_NONCEBYTES;
          nacl.box.overheadLength = nacl.secretbox.overheadLength;

          nacl.sign = function(msg, secretKey) {
            checkArrayTypes(msg, secretKey);
            if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
              throw new Error('bad secret key size');
            var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
            crypto_sign(signedMsg, msg, msg.length, secretKey);
            return signedMsg;
          };

          nacl.sign.open = function(signedMsg, publicKey) {
            checkArrayTypes(signedMsg, publicKey);
            if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
              throw new Error('bad public key size');
            var tmp = new Uint8Array(signedMsg.length);
            var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
            if (mlen < 0) return null;
            var m = new Uint8Array(mlen);
            for (var i = 0; i < m.length; i++) m[i] = tmp[i];
            return m;
          };

          nacl.sign.detached = function(msg, secretKey) {
            var signedMsg = nacl.sign(msg, secretKey);
            var sig = new Uint8Array(crypto_sign_BYTES);
            for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
            return sig;
          };

          nacl.sign.detached.verify = function(msg, sig, publicKey) {
            checkArrayTypes(msg, sig, publicKey);
            if (sig.length !== crypto_sign_BYTES)
              throw new Error('bad signature size');
            if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
              throw new Error('bad public key size');
            var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
            var m = new Uint8Array(crypto_sign_BYTES + msg.length);
            var i;
            for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
            for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
            return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
          };

          nacl.sign.keyPair = function() {
            var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
            var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
            crypto_sign_keypair(pk, sk);
            return {publicKey: pk, secretKey: sk};
          };

          nacl.sign.keyPair.fromSecretKey = function(secretKey) {
            checkArrayTypes(secretKey);
            if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
              throw new Error('bad secret key size');
            var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
            for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
            return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
          };

          nacl.sign.keyPair.fromSeed = function(seed) {
            checkArrayTypes(seed);
            if (seed.length !== crypto_sign_SEEDBYTES)
              throw new Error('bad seed size');
            var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
            var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
            for (var i = 0; i < 32; i++) sk[i] = seed[i];
            crypto_sign_keypair(pk, sk, true);
            return {publicKey: pk, secretKey: sk};
          };

          nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
          nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
          nacl.sign.seedLength = crypto_sign_SEEDBYTES;
          nacl.sign.signatureLength = crypto_sign_BYTES;

          nacl.hash = function(msg) {
            checkArrayTypes(msg);
            var h = new Uint8Array(crypto_hash_BYTES);
            crypto_hash(h, msg, msg.length);
            return h;
          };

          nacl.hash.hashLength = crypto_hash_BYTES;

          nacl.verify = function(x, y) {
            checkArrayTypes(x, y);
            // Zero length arguments are considered not equal.
            if (x.length === 0 || y.length === 0) return false;
            if (x.length !== y.length) return false;
            return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
          };

          nacl.setPRNG = function(fn) {
            randombytes = fn;
          };

          (function() {
            // Initialize PRNG if environment provides CSPRNG.
            // If not, methods calling randombytes will throw.
            var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
            if (crypto && crypto.getRandomValues) {
              // Browsers.
              var QUOTA = 65536;
              nacl.setPRNG(function(x, n) {
                var i, v = new Uint8Array(n);
                for (i = 0; i < n; i += QUOTA) {
                  crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
                }
                for (i = 0; i < n; i++) x[i] = v[i];
                cleanup(v);
              });
            } else if (typeof require !== 'undefined') {
              // Node.js.
              crypto = require('crypto');
              if (crypto && crypto.randomBytes) {
                nacl.setPRNG(function(x, n) {
                  var i, v = crypto.randomBytes(n);
                  for (i = 0; i < n; i++) x[i] = v[i];
                  cleanup(v);
                });
              }
            }
          })();

        })(typeof module !== 'undefined' && module.exports ? module.exports : (self.nacl = self.nacl || {}));

      },{"crypto":23}],141:[function(require,module,exports){
        'use strict';
        module.exports = require( './lib/u2f-api' );
      },{"./lib/u2f-api":143}],142:[function(require,module,exports){
// Copyright 2014 Google Inc. All rights reserved
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file or at
// https://developers.google.com/open-source/licenses/bsd

        /**
         * @fileoverview The U2F api.
         */

        'use strict';

        /** Namespace for the U2F api.
         * @type {Object}
         */
        var u2f = u2f || {};

        module.exports = u2f; // Adaptation for u2f-api package

        /**
         * The U2F extension id
         * @type {string}
         * @const
         */
        u2f.EXTENSION_ID = 'kmendfapggjehodndflmmgagdbamhnfd';

        /**
         * Message types for messsages to/from the extension
         * @const
         * @enum {string}
         */
        u2f.MessageTypes = {
          'U2F_REGISTER_REQUEST': 'u2f_register_request',
          'U2F_SIGN_REQUEST': 'u2f_sign_request',
          'U2F_REGISTER_RESPONSE': 'u2f_register_response',
          'U2F_SIGN_RESPONSE': 'u2f_sign_response'
        };

        /**
         * Response status codes
         * @const
         * @enum {number}
         */
        u2f.ErrorCodes = {
          'OK': 0,
          'OTHER_ERROR': 1,
          'BAD_REQUEST': 2,
          'CONFIGURATION_UNSUPPORTED': 3,
          'DEVICE_INELIGIBLE': 4,
          'TIMEOUT': 5
        };

        /**
         * A message type for registration requests
         * @typedef {{
 *   type: u2f.MessageTypes,
 *   signRequests: Array.<u2f.SignRequest>,
 *   registerRequests: ?Array.<u2f.RegisterRequest>,
 *   timeoutSeconds: ?number,
 *   requestId: ?number
 * }}
         */
        u2f.Request;

        /**
         * A message for registration responses
         * @typedef {{
 *   type: u2f.MessageTypes,
 *   responseData: (u2f.Error | u2f.RegisterResponse | u2f.SignResponse),
 *   requestId: ?number
 * }}
         */
        u2f.Response;

        /**
         * An error object for responses
         * @typedef {{
 *   errorCode: u2f.ErrorCodes,
 *   errorMessage: ?string
 * }}
         */
        u2f.Error;

        /**
         * Data object for a single sign request.
         * @typedef {{
 *   version: string,
 *   challenge: string,
 *   keyHandle: string,
 *   appId: string
 * }}
         */
        u2f.SignRequest;

        /**
         * Data object for a sign response.
         * @typedef {{
 *   keyHandle: string,
 *   signatureData: string,
 *   clientData: string
 * }}
         */
        u2f.SignResponse;

        /**
         * Data object for a registration request.
         * @typedef {{
 *   version: string,
 *   challenge: string,
 *   appId: string
 * }}
         */
        u2f.RegisterRequest;

        /**
         * Data object for a registration response.
         * @typedef {{
 *   registrationData: string,
 *   clientData: string
 * }}
         */
        u2f.RegisterResponse;


// Low level MessagePort API support

        /**
         * Call MessagePort disconnect
         */
        u2f.disconnect = function() {
          if (u2f.port_ && u2f.port_.port_) {
            u2f.port_.port_.disconnect();
            u2f.port_ = null;
          }
        };

        /**
         * Sets up a MessagePort to the U2F extension using the
         * available mechanisms.
         * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback
         */
        u2f.getMessagePort = function(callback) {
          if (typeof chrome != 'undefined' && chrome.runtime) {
            // The actual message here does not matter, but we need to get a reply
            // for the callback to run. Thus, send an empty signature request
            // in order to get a failure response.
            var msg = {
              type: u2f.MessageTypes.U2F_SIGN_REQUEST,
              signRequests: []
            };
            chrome.runtime.sendMessage(u2f.EXTENSION_ID, msg, function() {
              if (!chrome.runtime.lastError) {
                // We are on a whitelisted origin and can talk directly
                // with the extension.
                u2f.getChromeRuntimePort_(callback);
              } else {
                // chrome.runtime was available, but we couldn't message
                // the extension directly, use iframe
                u2f.getIframePort_(callback);
              }
            });
          } else {
            // chrome.runtime was not available at all, which is normal
            // when this origin doesn't have access to any extensions.
            u2f.getIframePort_(callback);
          }
        };

        /**
         * Connects directly to the extension via chrome.runtime.connect
         * @param {function(u2f.WrappedChromeRuntimePort_)} callback
         * @private
         */
        u2f.getChromeRuntimePort_ = function(callback) {
          var port = chrome.runtime.connect(u2f.EXTENSION_ID,
            {'includeTlsChannelId': true});
          setTimeout(function() {
            callback(null, new u2f.WrappedChromeRuntimePort_(port));
          }, 0);
        };

        /**
         * A wrapper for chrome.runtime.Port that is compatible with MessagePort.
         * @param {Port} port
         * @constructor
         * @private
         */
        u2f.WrappedChromeRuntimePort_ = function(port) {
          this.port_ = port;
        };

        /**
         * Posts a message on the underlying channel.
         * @param {Object} message
         */
        u2f.WrappedChromeRuntimePort_.prototype.postMessage = function(message) {
          this.port_.postMessage(message);
        };

        /**
         * Emulates the HTML 5 addEventListener interface. Works only for the
         * onmessage event, which is hooked up to the chrome.runtime.Port.onMessage.
         * @param {string} eventName
         * @param {function({data: Object})} handler
         */
        u2f.WrappedChromeRuntimePort_.prototype.addEventListener =
          function(eventName, handler) {
            var name = eventName.toLowerCase();
            if (name == 'message' || name == 'onmessage') {
              this.port_.onMessage.addListener(function(message) {
                // Emulate a minimal MessageEvent object
                handler({'data': message});
              });
            } else {
              console.error('WrappedChromeRuntimePort only supports onMessage');
            }
          };

        /**
         * Sets up an embedded trampoline iframe, sourced from the extension.
         * @param {function(MessagePort)} callback
         * @private
         */
        u2f.getIframePort_ = function(callback) {
          // Create the iframe
          var iframeOrigin = 'chrome-extension://' + u2f.EXTENSION_ID;
          var iframe = document.createElement('iframe');
          iframe.src = iframeOrigin + '/u2f-comms.html';
          iframe.setAttribute('style', 'display:none');
          document.body.appendChild(iframe);

          var hasCalledBack = false;

          var channel = new MessageChannel();
          var ready = function(message) {
            if (message.data == 'ready') {
              channel.port1.removeEventListener('message', ready);
              if (!hasCalledBack)
              {
                hasCalledBack = true;
                callback(null, channel.port1);
              }
            } else {
              console.error('First event on iframe port was not "ready"');
            }
          };
          channel.port1.addEventListener('message', ready);
          channel.port1.start();

          iframe.addEventListener('load', function() {
            // Deliver the port to the iframe and initialize
            iframe.contentWindow.postMessage('init', iframeOrigin, [channel.port2]);
          });

          // Give this 200ms to initialize, after that, we treat this method as failed
          setTimeout(function() {
            if (!hasCalledBack)
            {
              hasCalledBack = true;
              callback(new Error("IFrame extension not supported"));
            }
          }, 200);
        };


// High-level JS API

        /**
         * Default extension response timeout in seconds.
         * @const
         */
        u2f.EXTENSION_TIMEOUT_SEC = 30;

        /**
         * A singleton instance for a MessagePort to the extension.
         * @type {MessagePort|u2f.WrappedChromeRuntimePort_}
         * @private
         */
        u2f.port_ = null;

        /**
         * Callbacks waiting for a port
         * @type {Array.<function((MessagePort|u2f.WrappedChromeRuntimePort_))>}
         * @private
         */
        u2f.waitingForPort_ = [];

        /**
         * A counter for requestIds.
         * @type {number}
         * @private
         */
        u2f.reqCounter_ = 0;

        /**
         * A map from requestIds to client callbacks
         * @type {Object.<number,(function((u2f.Error|u2f.RegisterResponse))
 *                       |function((u2f.Error|u2f.SignResponse)))>}
         * @private
         */
        u2f.callbackMap_ = {};

        /**
         * Creates or retrieves the MessagePort singleton to use.
         * @param {function((MessagePort|u2f.WrappedChromeRuntimePort_))} callback
         * @private
         */
        u2f.getPortSingleton_ = function(callback) {
          if (u2f.port_) {
            callback(null, u2f.port_);
          } else {
            if (u2f.waitingForPort_.length == 0) {
              u2f.getMessagePort(function(err, port) {
                if (!err) {
                  u2f.port_ = port;
                  u2f.port_.addEventListener('message',
                    /** @type {function(Event)} */ (u2f.responseHandler_));
                }

                // Careful, here be async callbacks. Maybe.
                while (u2f.waitingForPort_.length)
                  u2f.waitingForPort_.shift()(err, port);
              });
            }
            u2f.waitingForPort_.push(callback);
          }
        };

        /**
         * Handles response messages from the extension.
         * @param {MessageEvent.<u2f.Response>} message
         * @private
         */
        u2f.responseHandler_ = function(message) {
          var response = message.data;
          var reqId = response['requestId'];
          if (!reqId || !u2f.callbackMap_[reqId]) {
            console.error('Unknown or missing requestId in response.');
            return;
          }
          var cb = u2f.callbackMap_[reqId];
          delete u2f.callbackMap_[reqId];
          cb(null, response['responseData']);
        };

        /**
         * Calls the callback with true or false as first and only argument
         * @param {Function} callback
         */
        u2f.isSupported = function(callback) {
          u2f.getPortSingleton_(function(err, port) {
            callback(!err);
          });
        }

        /**
         * Dispatches an array of sign requests to available U2F tokens.
         * @param {Array.<u2f.SignRequest>} signRequests
         * @param {function((u2f.Error|u2f.SignResponse))} callback
         * @param {number=} opt_timeoutSeconds
         */
        u2f.sign = function(signRequests, callback, opt_timeoutSeconds) {
          u2f.getPortSingleton_(function(err, port) {
            if (err)
              return callback(err);

            var reqId = ++u2f.reqCounter_;
            u2f.callbackMap_[reqId] = callback;
            var req = {
              type: u2f.MessageTypes.U2F_SIGN_REQUEST,
              signRequests: signRequests,
              timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?
                opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),
              requestId: reqId
            };
            port.postMessage(req);
          });
        };

        /**
         * Dispatches register requests to available U2F tokens. An array of sign
         * requests identifies already registered tokens.
         * @param {Array.<u2f.RegisterRequest>} registerRequests
         * @param {Array.<u2f.SignRequest>} signRequests
         * @param {function((u2f.Error|u2f.RegisterResponse))} callback
         * @param {number=} opt_timeoutSeconds
         */
        u2f.register = function(registerRequests, signRequests,
                                callback, opt_timeoutSeconds) {
          u2f.getPortSingleton_(function(err, port) {
            if (err)
              return callback(err);

            var reqId = ++u2f.reqCounter_;
            u2f.callbackMap_[reqId] = callback;
            var req = {
              type: u2f.MessageTypes.U2F_REGISTER_REQUEST,
              signRequests: signRequests,
              registerRequests: registerRequests,
              timeoutSeconds: (typeof opt_timeoutSeconds !== 'undefined' ?
                opt_timeoutSeconds : u2f.EXTENSION_TIMEOUT_SEC),
              requestId: reqId
            };
            port.postMessage(req);
          });
        };

      },{}],143:[function(require,module,exports){
        (function (global){
          'use strict';

          module.exports = API;

          var chromeApi = require( './google-u2f-api' );

// Feature detection (yes really)
          var isBrowser = ( typeof navigator !== 'undefined' ) && !!navigator.userAgent;
          var isSafari = isBrowser && navigator.userAgent.match( /Safari\// )
            && !navigator.userAgent.match( /Chrome\// );
          var isEDGE = isBrowser && navigator.userAgent.match( /Edge\/1[2345]/ );

          var _backend = null;
          function getBackend( Promise )
          {
            if ( !_backend )
              _backend = new Promise( function( resolve, reject )
              {
                function notSupported( )
                {
                  // Note; {native: true} means *not* using Google's hack
                  resolve( { u2f: null, native: true } );
                }

                if ( !isBrowser )
                  return notSupported( );

                if ( isSafari )
                // Safari doesn't support U2F, and the Safari-FIDO-U2F
                // extension lacks full support (Multi-facet apps), so we
                // block it until proper support.
                  return notSupported( );

                var hasNativeSupport =
                  ( typeof window.u2f !== 'undefined' ) &&
                  ( typeof window.u2f.sign === 'function' );

                if ( hasNativeSupport )
                  resolve( { u2f: window.u2f, native: true } );

                if ( isEDGE )
                // We don't want to check for Google's extension hack on EDGE
                // as it'll cause trouble (popups, etc)
                  return notSupported( );

                if ( location.protocol === 'http:' )
                // U2F isn't supported over http, only https
                  return notSupported( );

                if ( typeof MessageChannel === 'undefined' )
                // Unsupported browser, the chrome hack would throw
                  return notSupported( );

                // Test for google extension support
                chromeApi.isSupported( function( ok )
                {
                  if ( ok )
                    resolve( { u2f: chromeApi, native: false } );
                  else
                    notSupported( );
                } );
              } );

            return _backend;
          }

          function API( Promise )
          {
            return {
              isSupported   : isSupported.bind( Promise ),
              ensureSupport : ensureSupport.bind( Promise ),
              register      : register.bind( Promise ),
              sign          : sign.bind( Promise ),
              ErrorCodes    : API.ErrorCodes,
              ErrorNames    : API.ErrorNames
            };
          }

          API.ErrorCodes = {
            CANCELLED: -1,
            OK: 0,
            OTHER_ERROR: 1,
            BAD_REQUEST: 2,
            CONFIGURATION_UNSUPPORTED: 3,
            DEVICE_INELIGIBLE: 4,
            TIMEOUT: 5
          };
          API.ErrorNames = {
            "-1": "CANCELLED",
            "0": "OK",
            "1": "OTHER_ERROR",
            "2": "BAD_REQUEST",
            "3": "CONFIGURATION_UNSUPPORTED",
            "4": "DEVICE_INELIGIBLE",
            "5": "TIMEOUT"
          };

          function makeError( msg, err )
          {
            var code = err != null ? err.errorCode : 1; // Default to OTHER_ERROR
            var type = API.ErrorNames[ '' + code ];
            var error = new Error( msg );
            error.metaData = {
              type: type,
              code: code
            }
            return error;
          }

          function deferPromise( Promise, promise )
          {
            var ret = { };
            ret.promise = new Promise( function( resolve, reject ) {
              ret.resolve = resolve;
              ret.reject = reject;
              promise.then( resolve, reject );
            } );
            /**
             * Reject request promise and disconnect port if 'disconnect' flag is true
             * @param {string} msg
             * @param {boolean} disconnect
             */
            ret.promise.cancel = function( msg, disconnect )
            {
              getBackend( Promise )
                .then( function( backend )
                {
                  if ( disconnect && !backend.native )
                    backend.u2f.disconnect( );

                  ret.reject( makeError( msg, { errorCode: -1 } ) );
                } );
            };
            return ret;
          }

          function defer( Promise, fun )
          {
            return deferPromise( Promise, new Promise( function( resolve, reject )
            {
              try
              {
                fun && fun( resolve, reject );
              }
              catch ( err )
              {
                reject( err );
              }
            } ) );
          }

          function isSupported( )
          {
            var Promise = this;

            return getBackend( Promise )
              .then( function( backend )
              {
                return !!backend.u2f;
              } );
          }

          function _ensureSupport( backend )
          {
            if ( !backend.u2f )
            {
              if ( location.protocol === 'http:' )
                throw new Error( "U2F isn't supported over http, only https" );
              throw new Error( "U2F not supported" );
            }
          }

          function ensureSupport( )
          {
            var Promise = this;

            return getBackend( Promise )
              .then( _ensureSupport );
          }

          function register( registerRequests, signRequests /* = null */, timeout )
          {
            var Promise = this;

            if ( !Array.isArray( registerRequests ) )
              registerRequests = [ registerRequests ];

            if ( typeof signRequests === 'number' && typeof timeout === 'undefined' )
            {
              timeout = signRequests;
              signRequests = null;
            }

            if ( !signRequests )
              signRequests = [ ];

            return deferPromise( Promise, getBackend( Promise )
              .then( function( backend )
              {
                _ensureSupport( backend );

                var native = backend.native;
                var u2f = backend.u2f;

                return new Promise( function( resolve, reject )
                {
                  function cbNative( response )
                  {
                    if ( response.errorCode )
                      reject( makeError( "Registration failed", response ) );
                    else
                    {
                      delete response.errorCode;
                      resolve( response );
                    }
                  }

                  function cbChrome( err, response )
                  {
                    if ( err )
                      reject( err );
                    else if ( response.errorCode )
                      reject( makeError( "Registration failed", response ) );
                    else
                      resolve( response );
                  }

                  if ( native )
                  {
                    var appId = registerRequests[ 0 ].appId;

                    u2f.register(
                      appId, registerRequests, signRequests, cbNative, timeout );
                  }
                  else
                  {
                    u2f.register(
                      registerRequests, signRequests, cbChrome, timeout );
                  }
                } );
              } ) ).promise;
          }

          function sign( signRequests, timeout )
          {
            var Promise = this;

            if ( !Array.isArray( signRequests ) )
              signRequests = [ signRequests ];

            return deferPromise( Promise, getBackend( Promise )
              .then( function( backend )
              {
                _ensureSupport( backend );

                var native = backend.native;
                var u2f = backend.u2f;

                return new Promise( function( resolve, reject )
                {
                  function cbNative( response )
                  {
                    if ( response.errorCode )
                      reject( makeError( "Sign failed", response ) );
                    else
                    {
                      delete response.errorCode;
                      resolve( response );
                    }
                  }

                  function cbChrome( err, response )
                  {
                    if ( err )
                      reject( err );
                    else if ( response.errorCode )
                      reject( makeError( "Sign failed", response ) );
                    else
                      resolve( response );
                  }

                  if ( native )
                  {
                    var appId = signRequests[ 0 ].appId;
                    var challenge = signRequests[ 0 ].challenge;

                    u2f.sign( appId, challenge, signRequests, cbNative, timeout );
                  }
                  else
                  {
                    u2f.sign( signRequests, cbChrome, timeout );
                  }
                } );
              } ) ).promise;
          }

          function makeDefault( func )
          {
            API[ func ] = function( )
            {
              if ( !global.Promise )
              // This is very unlikely to ever happen, since browsers
              // supporting U2F will most likely support Promises.
                throw new Error( "The platform doesn't natively support promises" );

              var args = [ ].slice.call( arguments );
              return API( global.Promise )[ func ].apply( null, args );
            };
          }

// Provide default functions using the built-in Promise if available.
          makeDefault( 'isSupported' );
          makeDefault( 'ensureSupport' );
          makeDefault( 'register' );
          makeDefault( 'sign' );

        }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
      },{"./google-u2f-api":142}],144:[function(require,module,exports){
        const StellarLedger = module.exports;

        StellarLedger.Transport = require("@ledgerhq/hw-transport-u2f").default;
        StellarLedger.Api = require("@ledgerhq/hw-app-str").default;

        module.exports = StellarLedger;

      },{"@ledgerhq/hw-app-str":1,"@ledgerhq/hw-transport-u2f":3}]},{},[144])(144)
      });
    </script>
    <script src="scripts/app.js" inline></script>
  </body>
</html>
